<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5">
    <title>Word Worm</title>
    <meta name="google-site-verification" content="mi5zlh2EQ9mYTrAfD-LayBzy5iQ7ObatJbs40C8rcP4" />
    <meta property="og:title" content="Word Worm - The Fast-Paced Word Finding Game!">
    <meta property="og:description" content="Race against the clock to find words from a jumbled grid. Challenge friends and climb the daily leaderboards!">
    <meta property="og:image" content="https://wordwormgame.com/assets/word-worm-social-logo.png">
    <meta property="og:url" content="https://wordwormgame.com">
    <meta property="og:type" content="website">

    <meta property="og:site_name" content="Word Worm">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="The Word Worm game logo featuring a cartoon worm and letter blocks.">
    <meta property="og:locale" content="en_US">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Word Worm - The Fast-Paced Word Finding Game!">
    <meta name="twitter:description" content="Race against the clock to find words from a jumbled grid. Challenge friends and climb the daily leaderboards!">
    <meta name="twitter:image" content="https://wordwormgame.com/assets/word-worm-social-logo.png">
    <meta name="description" content="Race against the clock to find words from a jumbled grid. Challenge friends and climb the daily leaderboards!">

    <link rel="icon" href="assets/favicon.png?v=1.0" type="image/png">
    <link rel="apple-touch-icon" href="assets/favicon.png?v=1.0">

<link rel="preconnect" href="https://firebase.googleapis.com">
  <link rel="preconnect" href="https://apis.google.com">
  <link rel="preconnect" href="https://word-rush-game-9010a.firebaseapp.com">
  <link rel="preconnect" href="https://firestore.googleapis.com">

<link rel="stylesheet" href="./dist/style.css?v=1.6">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=block" media="print" onload="this.media='all'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=block"></noscript>
    <style>
        body { font-family: 'Inter', sans-serif; overflow: hidden; touch-action: none; }
        .tile {
            position: relative;
            transition: all 0.2s ease-in-out; -webkit-user-select: none; user-select: none;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
        .tile.selected {
            background: linear-gradient(45deg, #60a5fa, #3b82f6);
            color: white; transform: scale(1.08); border-color: #2563eb;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.2), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        #line-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        
        /* Bonus Tile Styles */
        .bonus-label {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.65rem;
            font-weight: 900;
            color: white;
            padding: 0px 4px;
            border-radius: 4px;
        }
        .bonus-DL { background-color: #3b82f6 !important; } /* Blue */
        .bonus-TL { background-color: #ef4444 !important; } /* Red */
        .bonus-DW { background-color: #f59e0b !important; } /* Amber */
        .bonus-Time { background-color: #22c55e !important; } /* Green */
        
        /* Animations */

@keyframes shake-sm {
    0%, 100% { transform: translate(-50%, -50%) translateX(0); }
    10%, 30%, 50%, 70%, 90% { transform: translate(-50%, -50%) translateX(-5px); }
    20%, 40%, 60%, 80% { transform: translate(-50%, -50%) translateX(5px); }
}
.animate-shake {
    animation: shake-sm 0.5s cubic-bezier(.36,.07,.19,.97) both;
}


                @keyframes fade-in-out {
            0%, 100% { opacity: 0; transform: translateY(10px); }
            10%, 90% { opacity: 1; transform: translateY(0); }
        }
        .game-message {
            animation: fade-in-out 2s ease-in-out forwards;
        }

      /* --- START: Tutorial-specific CSS --- */
.tut-tile {
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 0.375rem; /* rounded-md */
    font-weight: 700;
    font-size: 1.125rem; /* text-lg */
    color: #1e293b;
    background-color: white;
    border: 2px solid #cbd5e1;
    transition: all 0.3s ease-in-out;
    position: relative;
    -webkit-user-select: none;
    user-select: none;
}
.tut-tile sub {
    font-size: 0.6rem;
    font-weight: 600;
    margin-left: 2px;
    opacity: 0.8;
}
.tut-tile.highlight {
    transform: scale(1.1);
    background: linear-gradient(45deg, #60a5fa, #3b82f6);
    color: white;
    border-color: #2563eb;
}
.bonus-tl-tut { background-color: #ef4444 !important; color: white !important; }
.bonus-dw-tut { background-color: #f59e0b !important; color: white !important; }
.bonus-dl-tut { background-color: #3b82f6 !important; color: white !important; }
.bonus-time-tut { background-color: #22c55e !important; color: white !important; }
.tut-tile .bonus-label {
    position: absolute;
    top: 1px;
    right: 1px;
    font-size: 0.45rem; /* Smaller font */
    font-weight: 900;
    padding: 0px 2px; /* Tighter padding */
    border-radius: 3px;
    color: white;
    background-color: rgba(0, 0, 0, 0.25);
}
@keyframes bounce-sm {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-4px); }
}
.scroll-prompt-arrow {
    animation: bounce-sm 1.5s infinite;
}
.line-segment {
    position: absolute;
    background-color: rgba(59, 130, 246, 0.7);
    height: 6px;
    border-radius: 3px;
    transform-origin: left center;
    opacity: 0;
    transition: opacity 0.1s ease-in-out;
    z-index: 5; /* Ensure lines are on top of tiles */
}
@keyframes fly-up-score {
    0% { transform: translate(-50%, 0) scale(1); opacity: 1; }
    100% { transform: translate(-50%, -50px) scale(0.6); opacity: 0; }
}
.flying-score-tut {
    position: absolute;
    left: 50%;
    top: 40%;
    background: linear-gradient(45deg, #f59e0b, #d97706);
    color: white;
    padding: 4px 12px;
    border-radius: 9999px;
    font-weight: bold;
    font-size: 1rem;
    z-index: 20; /* Ensure score is on top of everything */
    animation: fly-up-score 1.5s ease-out forwards;
}
/* --- END: Tutorial-specific CSS --- */

               @keyframes pulse-text-glow {
  0%, 100% {
    transform: scale(1.05);
    text-shadow: 0 0 6px rgba(239, 68, 68, 0.6);
  }
  50% {
    transform: scale(1.15);
    text-shadow: 0 0 14px rgba(239, 68, 68, 0.8);
  }
}

.timer-warning {
  /* This applies the new text-based glow animation */
  animation: pulse-text-glow 1s infinite;
}
        
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .animate-pulse { animation: pulse 1s infinite; }
        @keyframes fly-to-score {
            0% { transform: translate(0, 0) scale(1.2); opacity: 1; }
            100% { transform: translate(0, -180px) scale(0.5); opacity: 0; }
        }
        .flying-score {
            position: absolute; background: linear-gradient(45deg, #facc15, #f59e0b); color: white;
            padding: 8px 16px; border-radius: 9999px; font-weight: bold; font-size: 1.25rem;
            z-index: 100; animation: fly-to-score 1.5s ease-in-out forwards; pointer-events: none;
        }
        @keyframes pop-in {
            0% { transform: scale(0.8); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .current-letter { animation: pop-in 0.2s ease-out; }
        .modal-enter { animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }
        .tab-button.active {
            background-color: #3b82f6;
            color: white;
        }
        
        /* Tutorial Animation */
        .tutorial-tile.highlight {
            background: linear-gradient(45deg, #60a5fa, #3b82f6);
            color: white;
            transform: scale(1.08);
            border-color: #2563eb;
        }
        @keyframes fly-up-tutorial {
            0% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
            100% { transform: translate(-50%, -200%) scale(0.5); opacity: 0; }
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-8px); }
        }
        .animate-bounce-slow {
            animation: bounce 1.5s infinite;
        }

        .particle {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #facc15;
            z-index: 101;
            animation: particle-anim 1.2s ease-out forwards;
        }

        @keyframes particle-anim {
            to {
                transform: var(--transform-end);
                opacity: 0;
            }
        }
        
        
    </style>
</head>
<body class="bg-slate-100 flex justify-center items-start md:items-center min-h-screen">

    <div id="game-container" class="w-full max-w-sm mx-auto p-4 relative">

        <div id="menu-container" class="absolute top-4 right-4 z-30 hidden">
            <button id="menu-button" class="text-slate-700 p-2 transition-transform hover:scale-105">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
                </svg>
            </button>
        </div>

        <div id="game-content" class="z-0 hidden">
            <div class="flex items-center justify-between mb-3">
                <div class="flex-grow flex items-center justify-center">
                    <h1 class="text-3xl font-black text-slate-800 tracking-tighter flex items-center justify-center">
                        <img src="assets/word-worm-logo-icon.webp" alt="Word Worm Logo" class="w-9 h-9 mr-2" width="36" height="36">
                        <span>Word Worm</span>
                    </h1>
                </div>
            </div>
            <div id="scoreboard" class="grid grid-cols-3 items-center text-center bg-white rounded-xl shadow-lg p-2 mb-3">
                <div id="top-left-display">
                    <div class="text-xs font-bold text-slate-500 uppercase tracking-wider">High</div>
                    <div id="high-score" class="text-3xl font-black text-slate-400">0</div>
                </div>
                <div>
                    <div class="text-xs font-bold text-slate-500 uppercase tracking-wider">Score</div>
                    <div id="score" class="text-3xl font-black text-slate-800">0</div>
                </div>
                <div id="timer-display">
                    <div class="text-xs font-bold text-slate-500 uppercase tracking-wider">Time</div>
                    <div id="timer" class="text-3xl font-bold text-green-500 transition-all duration-300">60</div>
                </div>
            </div>
            <div id="current-word-container" class="mb-3 p-2 bg-slate-200 rounded-lg shadow-inner h-[52px] flex items-center justify-center">
                <div id="current-word-letters" class="flex-grow flex items-center justify-center space-x-1"></div>
            </div>
            <div id="grid-container" class="relative">
                <canvas id="line-canvas"></canvas>
                <div id="grid" class="grid grid-cols-4 gap-2 select-none"></div>
            </div>
            <footer id="main-game-footer" style="margin-top: 3rem;">
                <div class="text-center text-xs text-slate-400 mt-4">
                    <p>&copy; 2025 Word Worm</p>
                    <p>
                        <a href="/about.html" class="hover:underline">About</a> &bull;
                        <a href="/contact.html" class="hover:underline">Contact</a> &bull;
                        <a href="/privacy.html" class="hover:underline">Privacy Policy</a> &bull;
                        <a href="/terms.html" class="hover:underline">Terms of Use</a>
                    </p>
                </div>
            </footer>
        </div>

        <div id="daily-challenge-content" class="hidden"></div>

    </div> 
    
    <div id="message-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-20 p-4">
        <div id="modal-content" class="w-full max-w-sm mx-auto"></div>
    </div>
    <div id="end-game-modal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4">
        <div id="end-game-modal-content" class="w-full max-w-sm mx-auto"></div>
    </div>
    <div id="leaderboard-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-[60] p-4">
        <div id="leaderboard-modal-content" class="w-full max-w-xs mx-auto"></div>
    </div>
    <div id="stats-modal" class="hidden fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-[70] p-4 overflow-y-auto">
        <div id="stats-modal-content" class="w-full max-w-xs mx-auto"></div>
    </div>
    <div id="pause-modal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-40 p-4">
        <div class="bg-white rounded-2xl shadow-2xl p-6 w-full max-w-xs mx-auto text-center modal-enter relative">
            <button id="close-pause-modal-button" class="absolute top-4 right-4 text-3xl leading-none text-slate-400 hover:text-slate-800">&times;</button>
            <div class="flex justify-center items-center mb-4 mt-2">
                <h2 class="text-2xl font-bold text-slate-800 flex items-center">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 mr-2 text-black">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M14.25 9v6m-4.5 0V9M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" />
                    </svg>
                    <span>Game Paused</span>
                </h2>
            </div>
            <div class="space-y-3">
                <button id="resume-game-button" class="w-full flex items-center justify-center bg-white hover:bg-slate-50 text-slate-700 font-bold py-3 px-4 rounded-lg text-base shadow-md transition-colors border border-slate-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 mr-2 text-green-500">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.347a1.125 1.125 0 0 1 0 1.972l-11.54 6.347a1.125 1.125 0 0 1-1.667-.986V5.653Z" />
                    </svg>
                    <span>Resume Game</span>
                </button>
                <button id="restart-game-button" class="w-full flex items-center justify-center bg-white hover:bg-slate-50 text-slate-700 font-bold py-3 px-4 rounded-lg text-base shadow-md transition-colors border border-slate-200">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 mr-2 text-blue-500">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
                    </svg>
                    <span>New Game</span>
                </button>
                <button id="quit-game-button" class="w-full flex items-center justify-center bg-white hover:bg-slate-50 text-slate-700 font-bold py-3 px-4 rounded-lg text-base shadow-md transition-colors border border-slate-200">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 mr-2 text-orange-500">                    <path stroke-linecap="round" stroke-linejoin="round" d="m2.25 12 8.954-8.955c.44-.439 1.152-.439 1.591 0L21.75 12M4.5 9.75v10.125c0 .621.504 1.125 1.125 1.125H9.75v-4.875c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125V21h4.125c.621 0 1.125-.504 1.125-1.125V9.75M8.25 21h7.5" />
                    </svg>
                    <span>Return Home</span>
                </button>
            </div>
        </div>
    </div>



<script type="module" defer>
    // --- Firebase SDKs ---
    import { getApps, initializeApp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-auth.js";
    import { getFirestore, collection, addDoc, getDocs, query, where, orderBy, limit, doc, getDoc, setDoc, updateDoc, increment, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-firestore.js";

    // --- Google Analytics ---
    import { getAnalytics, logEvent, setUserId } from "https://www.gstatic.com/firebasejs/11.9.0/firebase-analytics.js";
    
    // --- Config ---
    const [GRID_SIZE, GRID_COLS, GAME_TIME] = [16, 4, 60];
    const letterConfig={'A':{p:1},'B':{p:3},'C':{p:3},'D':{p:2},'E':{p:1},'F':{p:4},'G':{p:2},'H':{p:4},'I':{p:1},'J':{p:8},'K':{p:5},'L':{p:1},'M':{p:3},'N':{p:1},'O':{p:1},'P':{p:3},'Q':{p:10},'R':{p:1},'S':{p:1},'T':{p:1},'U':{p:1},'V':{p:4},'W':{p:4},'X':{p:8},'Y':{p:4},'Z':{p:10}};
    const VOWELS = ['A', 'E', 'I', 'O', 'U'];
    const HARD_CONSONANTS = ['J', 'K', 'Q', 'X', 'Z'];
    const LETTER_BAG_STRING = "EEEEEEEEEEEEAAAAAAAAAARRRRRRRRRRIIIIIIIIIOOOOOOOOTTTTTTTTNNNNNNNNSSSSSSSLLLLLLUUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";

    // --- DOM Elements ---
    const gameContainer = document.getElementById('game-container');
    const gameContentEl = document.getElementById('game-content');
    const gridContainer = document.getElementById('grid-container');
    const grid = document.getElementById('grid'), lineCanvas = document.getElementById('line-canvas'), ctx = lineCanvas.getContext('2d');
    const scoreEl = document.getElementById('score'), timerEl = document.getElementById('timer');
    const topLeftDisplayEl = document.getElementById('top-left-display');
    const menuContainer = document.getElementById('menu-container');
    const menuButton = document.getElementById('menu-button');
    const currentWordLettersEl = document.getElementById('current-word-letters');
    const messageModal = document.getElementById('message-modal'), modalContent = document.getElementById('modal-content');
    const endGameModal = document.getElementById('end-game-modal'), endGameModalContent = document.getElementById('end-game-modal-content');
    const leaderboardModal = document.getElementById('leaderboard-modal'), leaderboardModalContent = document.getElementById('leaderboard-modal-content');
    const statsModal = document.getElementById('stats-modal'), statsModalContent = document.getElementById('stats-modal-content');

    // --- Firebase State ---
    let auth, db, userId, analytics;

    // --- Game State ---
    let score = 0, timer = GAME_TIME, timerInterval, foundWords = [], selectedTiles = [], isMouseDown = false;
    let validationTrie;       // For checking if a board is playable
    let fullDictionaryTrie;   // For checking player-submitted words
    let tilePositions = [];
    let isPracticeMode = false;
    let practiceTimeElapsed = 0;
    let animationInterval;
    let currentGamemode = 'standard';
    let dailyChallengeData = null; 
    let allDailyWords = new Set();
    let activeGridEl;
    let activeCanvasEl;
    let activeCtx;

    /// --- Trie Data Structure ---
    class Trie {
        constructor(data = null) {
            this.root = data || {}; 
        }
        search(word, isPrefix = false) {
            let node = this.root;
            for (const char of word) {
                if (!node[char]) return false;
                node = node[char];
            }
            return isPrefix ? true : node.isEndOfWord === true;
        }
    }


    // Creates a seed (a number) from any string (like a date)
function stringToSeed(str) {
    let hash = 0;
    if (str.length === 0) return hash;
    for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash |= 0; // Convert to 32bit integer
    }
    return hash;
}

// A simple seeded random number generator (PRNG)
function mulberry32(seed) {
    return function() {
      let t = seed += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
}

/**
 * Creates the board for the daily challenge, ensuring it meets specific quality criteria.
 * @returns {Object} An object containing the board array and the set of all possible words.
 */
function createDailyChallengeBoard() {
    const todayStr = new Date().toLocaleDateString('en-CA');
    let attempt = 0;

    while (attempt < 2000) {
        const seed = stringToSeed(`${todayStr}-${attempt}`);
        const rng = mulberry32(seed);
        const board = new Array(GRID_SIZE).fill(null).map(() => getRandomLetterSeeded(rng));

        // --- 1. Basic Board Health Checks ---
        const vowelCount = board.filter(letter => VOWELS.includes(letter)).length;
        if (vowelCount < 4 || vowelCount > 8) { attempt++; continue; }
        const hardConsonantCount = board.filter(letter => HARD_CONSONANTS.includes(letter)).length;
        if (hardConsonantCount > 2) { attempt++; continue; }
        const qIndex = board.indexOf("Q");
        if (qIndex !== -1 && !getNeighbors(qIndex, board).some(letter => letter === "U")) { attempt++; continue; }
        if (!checkNoClumps(board)) { attempt++; continue; }

        // --- 2. Word-Based Validation ---
        const commonWords = solveBoard(board, validationTrie);
        const allWords = solveBoard(board, fullDictionaryTrie);

        // ✅ FIX: The rule is now simpler: just require at least one word that is 6+ letters long.
        const hasLongWord = Array.from(allWords).some(w => w.length >= 6);

        // Check our main rules plus the new long word rule.
        if (commonWords.size >= 30 && allWords.size <= 60 && hasLongWord) {
            console.log(`Daily board found for ${todayStr} in ${attempt + 1} attempts.`);
            console.log(`Board Stats: ${commonWords.size} common, ${allWords.size - commonWords.size} non-common. Total: ${allWords.size}.`);
            console.log("All possible daily words:", Array.from(allWords).sort());
            
            const indices = Array.from({length: 16}, (_, i) => i);
            let bonusTypes = ['DW', 'DW', 'TL', 'DL', 'DL', 'DL'];

            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            for (let i = bonusTypes.length - 1; i > 0; i--) {
                const j = Math.floor(rng() * (i + 1));
                [bonusTypes[i], bonusTypes[j]] = [bonusTypes[j], bonusTypes[i]];
            }

            const bonuses = indices.slice(0, 6).map((tileIndex, i) => ({
                index: tileIndex,
                type: bonusTypes[i]
            }));

            return {
                board: board,
                allWords: allWords,
                bonuses: []
            };
        }
        
        attempt++;
    }

    console.error("Failed to generate a daily board that meets the criteria.");
    return { board: ['W','O','R','D','W','O','R','M','G','A','M','E','P','L','A','Y'], allWords: new Set(), bonuses: [] };
}

    // --- Init ---
    function main() {
        setupEventListeners();
        topLeftDisplayEl.innerHTML = `<div class="text-xs font-bold text-slate-500 uppercase tracking-wider">High</div><div id="high-score" class="text-3xl font-black text-slate-400">0</div>`;
        showWelcomeScreen();
        loadAssets(); 
    }

async function showDailyEndScreen(stats, isNewSubmission = true) {
    endGameModal.classList.remove('hidden');
    endGameModalContent.innerHTML = `
        <div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm mx-auto modal-enter">
            <h2 class="text-2xl font-black text-green-500">Daily Challenge Complete!</h2>
            <p class="text-slate-600 my-4">Calculating your final results...</p>
            <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-slate-900 mx-auto"></div>
        </div>`;

    if (isNewSubmission) {
        if (activeGridEl) activeGridEl.style.pointerEvents = 'none';
        
        await submitDailyScoreToLeaderboard(stats.score);

        if (db && userId) {
            try {
                const todayStr = new Date().toLocaleDateString('en-CA');
                const dailyDocRef = doc(db, `players/${userId}/dailyChallenges`, todayStr);
                await setDoc(dailyDocRef, { completed: true, score: stats.score, foundWords: stats.foundWords }, { merge: true });
            } catch (error) {
                console.error("Error marking daily challenge as complete:", error);
            }
        }
    }
    
    const foundWordsSet = new Set(stats.foundWords.map(fw => fw.word));
    const allWordsSorted = Array.from(allDailyWords).sort();
    const allWordsHTML = allWordsSorted.map(word => {
        const isFound = foundWordsSet.has(word);
        const tileClasses = isFound ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800';
        return `<span class="${tileClasses} font-semibold text-xs px-2 py-1 rounded-md shadow-sm">${word.toUpperCase()}</span>`;
    }).join('');

    const foundCount = stats.foundWords.length;
    const totalCount = stats.totalCount;
    const percentage = totalCount > 0 ? Math.round((foundCount / totalCount) * 100) : 0;

    endGameModalContent.innerHTML = `
        <div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm mx-auto modal-enter">
             <h2 class="text-2xl font-black text-green-500">Daily Challenge Complete!</h2>
            <p class="text-slate-600 mb-2 mt-2">Your final score is:</p>
            <p id="final-score-display" class="text-6xl font-black text-slate-800 mb-3">${stats.score}</p>
            <div id="daily-summary-container" class="h-14 flex items-center justify-center"></div>
            <hr class="my-4">
            <div class="text-left w-full">
                <h3 class="text-lg font-bold text-slate-700 mb-2">All Possible Words (${foundCount}/${totalCount})</h3>
                <div class="flex flex-wrap gap-2 max-h-24 overflow-y-auto pr-2">${allWordsHTML}</div>
            </div>
            <div id="share-link-container" class="h-10 flex items-center justify-center mt-4"></div>
            <div class="flex space-x-2 mt-2">
                <button id="endgame-leaderboard-button" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold py-3 px-4 rounded-lg text-base flex-1">Leaderboard</button>
                <button id="return-home-button" class="bg-green-500 hover:bg-green-600 w-full text-white font-bold py-3 px-4 rounded-lg text-base flex-1">Return Home</button>
            </div>
            <div class="text-center text-xs text-slate-400 mt-4">
                <p>&copy; 2025 Word Worm</p>
                <p><a href="/about.html" class="hover:underline">About</a> &bull; <a href="/contact.html" class="hover:underline">Contact</a> &bull; <a href="/privacy.html" class="hover:underline">Privacy Policy</a> &bull; <a href="/terms.html" class="hover:underline">Terms of Use</a></p>
            </div>
        </div>`;
    
    const summaryContainer = document.getElementById('daily-summary-container');
    const showSummaryText = () => {
        const checkIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>`;
        summaryContainer.innerHTML = `<p class="text-base font-bold text-green-600 flex items-center justify-center">${checkIcon}<span>You found ${foundCount} / ${totalCount} words (${percentage}%)</span></p>`;
    };

    const playerName = localStorage.getItem('wordRushPlayerName');
    if ((!playerName || playerName === 'Anonymous') && isNewSubmission) {
        summaryContainer.innerHTML = `
            <div class="w-full">
                <div class="flex space-x-2">
                    <input type="text" id="player-name-daily" placeholder="Enter your name" class="w-full px-3 py-2 border border-slate-300 rounded-lg" maxlength="10">
                    <button id="submit-name-daily" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Submit</button>
                </div>
            </div>`;
        
        const nameInput = document.getElementById('player-name-daily');
        const submitBtn = document.getElementById('submit-name-daily');
        
        submitBtn.onclick = async () => {
            const newPlayerName = nameInput.value.trim();
            if (newPlayerName) {
                submitBtn.disabled = true;
                submitBtn.textContent = '...';
                localStorage.setItem('wordRushPlayerName', newPlayerName);
                
                if (userId && db) {
                    const playerDocRef = doc(db, "players", userId);
                    await setDoc(playerDocRef, { name: newPlayerName, hasSubmittedName: true }, { merge: true });
                }
                
                await submitDailyScoreToLeaderboard(stats.score);
                showSummaryText();
            }
        };
    } else {
        showSummaryText();
    }
    
    const scoreDisplay = document.getElementById('final-score-display');
    if (scoreDisplay) {
        triggerEndGameConfetti(scoreDisplay);
    }
    
    document.getElementById('return-home-button').onclick = resetGame;
    document.getElementById('endgame-leaderboard-button').onclick = showLeaderboardModal;

    const shareLinkContainer = document.getElementById('share-link-container');
    if (navigator.share || navigator.clipboard) {
        const shareIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z" /></svg>`;        shareLinkContainer.innerHTML = `<a href="#" id="share-score-link" class="flex items-center text-blue-500 hover:underline font-bold">${shareIcon} Share Score</a>`;
        document.getElementById('share-score-link').onclick = (e) => { e.preventDefault(); shareScore(); };
    }
}

function showSubmitConfirmation() {
    const modal = document.getElementById('message-modal');
    const content = document.getElementById('modal-content');
    if (!modal || !content) return;

    content.innerHTML = `
        <div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-xs mx-auto modal-enter">
            <div class="flex justify-center items-center mb-4">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
            </div>
            <h3 class="text-xl font-bold text-slate-800">You've found ${foundWords.length}/${allDailyWords.size} words!</h3>
            <p class="text-sm text-slate-500 mt-2 mb-6">Ready to submit? You can only play the daily challenge once per day.</p>
            <div class="flex space-x-2">
                <button id="cancel-submit-button" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold py-3 px-4 rounded-lg text-base flex-1">Cancel</button>
                <button id="confirm-submit-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-4 rounded-lg text-base flex-1">Submit</button>
            </div>
        </div>
    `;

    const confirmBtn = document.getElementById('confirm-submit-button');
    const cancelBtn = document.getElementById('cancel-submit-button');

    const hideModal = () => {
        modal.classList.add('hidden');
        modal.style.zIndex = ''; 
        content.innerHTML = ''; 
    };

    confirmBtn.onclick = () => {
        // ✅ FIX: 1. Immediately hide the confirmation and show the loading screen.
        hideModal();
        const stats = { score: score, foundWords: foundWords, totalCount: allDailyWords.size };
        endGameModal.classList.remove('hidden');
        endGameModalContent.innerHTML = `
            <div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm mx-auto modal-enter">
                <h2 class="text-2xl font-black text-green-500">Daily Challenge Complete!</h2>
                <p class="text-slate-600 my-4">Submitting your score...</p>
                <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-slate-900 mx-auto"></div>
            </div>`;

        // ✅ FIX: 2. Use a timeout to run the slow database logic AFTER the screen updates.
        setTimeout(() => {
            showDailyEndScreen(stats, true);
        }, 100); // A tiny delay is all that's needed
    };

    cancelBtn.onclick = hideModal;
    modal.onclick = (e) => { if (e.target === modal) hideModal(); };
    modal.style.zIndex = '40';
    modal.classList.remove('hidden');
}
    
    async function loadAssets() {
    const playGameModeButton = document.getElementById('play-game-mode-button');
    const playPracticeButton = document.getElementById('play-practice-button');
    const dailyChallengeButton = document.getElementById('play-daily-button');
    const loadingErrorEl = document.getElementById('loading-error');
    const globalPlayCountSpan = document.getElementById('global-play-count');

    const initializeFirebase = async () => {
        try {
            // ✅ FIX: Check if Firebase is already initialized to prevent errors
            if (getApps().length > 0) {
                return; // If it is, don't do anything.
            }

            const firebaseConfig = {
                apiKey: "AIzaSyC_DYC4l4DxZNBpOF-1tWlTJj0pG8910F0",
                authDomain: "wordworm-test-c7f3a.firebaseapp.com",
                projectId: "wordworm-test-c7f3a",
                storageBucket: "wordworm-test-c7f3a.firebasestorage.app",
                messagingSenderId: "912527691093",
                appId: "1:912527691093:web:bd22a2205b39f009e1b3dc"
                };

            const app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            analytics = getAnalytics(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    if (analytics && userId) {
                        setUserId(analytics, userId);
                    }
                    console.log("Firebase connected. User ID:", userId);
                    fetchGlobalStats();
                    fetchPlayerStats(userId);
                } else {
                    signInAnonymously(auth).catch(err => console.error("Anonymous sign-in failed:", err));
                }
            });
        } catch (firebaseError) {
            console.warn("Firebase features failed to load, continuing in offline mode:", firebaseError);
            if (globalPlayCountSpan) globalPlayCountSpan.textContent = "N/A";
        }
    };
    
    const loadDictionaryAndEnableButtons = async () => {
        if (playGameModeButton && playGameModeButton.disabled) return; // Don't re-run if already loaded
        
        if (playGameModeButton) {
            playGameModeButton.disabled = true;
            playGameModeButton.innerHTML = `<div class="flex items-center justify-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading...</span></div>`;
        }
        if (playPracticeButton) { playPracticeButton.disabled = true; }
        if (dailyChallengeButton) {
            dailyChallengeButton.disabled = true;
            dailyChallengeButton.innerHTML = `<div class="flex items-center justify-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading...</span></div>`;
        }
        
        try {
            if (fullDictionaryTrie) { // Dictionaries are already loaded
                console.log("Dictionaries already loaded.");
            } else {
                const [commonRes, fullRes] = await Promise.all([
                    fetch('assets/common-dictionary.json'),
                    fetch('assets/scrabble-dictionary.json')
                ]);
                if (!commonRes.ok || !fullRes.ok) throw new Error(`Dictionary download failed`);
                validationTrie = new Trie(await commonRes.json());
                fullDictionaryTrie = new Trie(await fullRes.json());
                console.log("Both dictionaries loaded. Game is playable.");
            }

            if (playGameModeButton) {
                playGameModeButton.disabled = false;
                playGameModeButton.innerHTML = `<div class="flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="white" class="w-6 h-6 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 0 1-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 0 0 6.16-12.12A14.98 14.98 0 0 0 9.631 8.41m5.96 5.96a14.926 14.926 0 0 1-5.841 2.58m-.119-8.54a6 6 0 0 0-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 0 0-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 0 1-2.448-2.448 14.9 14.9 0 0 1 .06-.312m-2.24 2.39a4.493 4.493 0 0 0-1.757 4.306 4.493 4.493 0 0 0 4.306-1.758M16.5 9a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z" /></svg><span>Play</span></div>`;
            }
            if (playPracticeButton) { playPracticeButton.disabled = false; }
            if (dailyChallengeButton) {
                dailyChallengeButton.disabled = false;
                dailyChallengeButton.innerHTML = `<div class="flex items-center justify-center"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M14.25 6.087c0-.355.186-.676.401-.959.221-.29.349-.634.349-1.003 0-1.036-1.007-1.875-2.25-1.875s-2.25.84-2.25 1.875c0 .369.128.713.349 1.003.215.283.401.604.401.959v0a.64.64 0 0 1-.657.643 48.39 48.39 0 0 1-4.163-.3c.186 1.613.293 3.25.315 4.907a.656.656 0 0 1-.658.663v0c-.355 0-.676-.186-.959-.401a1.647 1.647 0 0 0-1.003-.349c-1.036 0-1.875 1.007-1.875 2.25s.84 2.25 1.875 2.25c.369 0 .713-.128 1.003-.349.283-.215.604-.401.959-.401v0c.31 0 .555.26.532.57a48.039 48.039 0 0 1-.642 5.056c1.518.19 3.058.309 4.616.354a.64.64 0 0 0 .657-.643v0c0-.355-.186-.676-.401-.959a1.647 1.647 0 0 1-.349-1.003c0-1.035 1.008-1.875 2.25-1.875 1.243 0 2.25.84 2.25 1.875 0 .369-.128.713-.349 1.003-.215.283-.4.604-.4.959v0c0 .333.277.599.61.58a48.1 48.1 0 0 0 5.427-.63 48.05 48.05 0 0 0 .582-4.717.532.532 0 0 0-.533-.57v0c-.355 0-.676.186-.959.401-.29.221-.634.349-1.003.349-1.035 0-1.875-1.007-1.875-2.25s.84-2.25 1.875-2.25c.37 0 .713.128 1.003.349.283.215.604.401.96.401v0a.656.656 0 0 0 .658-.663 48.422 48.422 0 0 0-.37-5.36c-1.886.342-3.81.574-5.766.689a.578.578 0 0 1-.61-.58v0Z" /></svg><span>Daily Challenge</span></div>`;
            }

        } catch (e) {
            console.error("Critical Asset loading failed (Dictionaries):", e);
            if (loadingErrorEl) loadingErrorEl.textContent = "Error: Could not load game dictionaries.";
            if (playGameModeButton) { playGameModeButton.innerHTML = `<span>Error</span>`; playGameModeButton.classList.add('bg-red-500'); }
            if (playPracticeButton) { playPracticeButton.innerHTML = `<span>Error</span>`; playPracticeButton.classList.add('bg-red-500'); }
            if (dailyChallengeButton) { dailyChallengeButton.innerHTML = `<span>Error</span>`; dailyChallengeButton.classList.add('bg-red-500'); }
        }
    };
    
    initializeFirebase();
    loadDictionaryAndEnableButtons();
}

function showGameMessage(message, type = 'info', startTile = null) {
    const colors = {
        info: 'bg-slate-700',
        error: 'bg-red-500',
        success: 'bg-green-500'
    };

    // ✅ FIX: In daily mode, center the message over the grid and apply a shake animation.
    if (currentGamemode === 'daily' && activeGridEl) {
        const gridWrapper = activeGridEl.parentElement;
        if (gridWrapper) {
            gridWrapper.style.position = 'relative'; 
            const messageEl = document.createElement('div');
            // Add the new animate-shake class
            messageEl.className = `animate-shake absolute top-1/2 left-1/2 ${colors[type]} text-white text-sm font-bold px-4 py-2 rounded-full shadow-lg z-20`;
            messageEl.textContent = message;
            
            gridWrapper.appendChild(messageEl);
            // The message will disappear after the animation (1s)
            setTimeout(() => messageEl.remove(), 1000); 
        }
        return; 
    }

    // --- Fallback for other game modes ---
    const parentEl = document.body;
    const messageEl = document.createElement('div');
    messageEl.className = `game-message fixed bottom-20 left-1/2 -translate-x-1/2 text-white text-sm font-bold px-4 py-2 rounded-full shadow-lg ${colors[type]}`;
    messageEl.textContent = message;
    parentEl.appendChild(messageEl);
    setTimeout(() => messageEl.remove(), 1000);
}

    async function fetchGlobalStats() {
        const globalPlayCountSpan = document.getElementById('global-play-count');
        if (!db || !globalPlayCountSpan) return;
        try {
            const statsRef = doc(db, "gameStats", "stats");
            const docSnap = await getDoc(statsRef);
            if (docSnap.exists()) {
                globalPlayCountSpan.textContent = docSnap.data().playCount.toLocaleString();
            } else {
                globalPlayCountSpan.textContent = "0";
            }
        } catch(e) {
            console.warn("Could not fetch global stats:", e);
            if (globalPlayCountSpan) globalPlayCountSpan.textContent = "N/A";
        }
    }

    async function fetchPlayerStats(uid) {
    if (!db) return;
    const playerDocRef = doc(db, "players", uid);
    try {
        const docSnap = await getDoc(playerDocRef);
        let highScore = 0;
        let playerName = 'Anonymous';

        if (docSnap.exists()) {
            const playerData = docSnap.data();
            highScore = playerData.highScore || 0;
            playerName = playerData.name && playerData.name !== 'Anonymous' ? playerData.name : 'Anonymous';
        }

           // ✅ FIX: Sync the official name from Firebase to Local Storage
        localStorage.setItem('wordRushPlayerName', playerName);

        const highScoreEl = document.getElementById('high-score');
        if (highScoreEl) highScoreEl.textContent = highScore;

        const welcomeHighScoreEl = document.getElementById('welcome-high-score');
        if (welcomeHighScoreEl) welcomeHighScoreEl.textContent = highScore.toLocaleString();
        
        // Updated logic for personalized greeting
        const playerGreetingEl = document.getElementById('player-greeting');
        if (playerGreetingEl) {
            if (playerName !== 'Anonymous') {
                playerGreetingEl.innerHTML = `Welcome back, <strong class="font-bold">${playerName}</strong>!`;
            } else {
                playerGreetingEl.innerHTML = `Playing as <strong class="font-bold">Anonymous</strong>`;
            }
        }

    } catch (e) {
        console.error("Could not fetch player stats:", e);
    }
}
    
   function createGrid(board, gridEl, bonuses = null) {
    if (!gridEl) return; 

    gridEl.innerHTML = ''; 
    const bonusLabels = {
        'DL': { label: 'DL', class: 'bonus-DL' },
        'TL': { label: 'TL', class: 'bonus-TL' },
        'DW': { label: 'DW', class: 'bonus-DW' },
    };
    
    board.forEach((letterData, i) => {
        const letter = typeof letterData === 'object' ? letterData.letter : letterData;
        const points = letterConfig[letter].p;
        const tile = document.createElement('div');
        tile.className = 'tile w-full aspect-square border-2 border-slate-300 bg-white rounded-lg flex items-center justify-center text-3xl font-bold text-slate-800 cursor-pointer';
        tile.dataset.letter = letter;
        tile.dataset.points = points;
        tile.dataset.id = i;
        tile.innerHTML = `<span>${letter}<sub class="text-xs font-semibold ml-1">${points}</sub></span>`;
        
        let bonusType = null;
        // ✅ FIX: Check for deterministic bonuses first
        if (bonuses) {
            const bonusInfo = bonuses.find(b => b.index === i);
            if (bonusInfo) {
                bonusType = bonusLabels[bonusInfo.type];
                tile.dataset.bonus = bonusInfo.type;
            }
        } else {
             // ✅ FIX: Add a check to prevent bonus tiles in the daily challenge
            if (currentGamemode !== 'daily') {
                const randomBonus = getBonusType();
                if (randomBonus) {
                    bonusType = randomBonus;
                    tile.dataset.bonus = randomBonus.type;
                }
        }
    }

        if (bonusType) {
            tile.classList.add(bonusType.class);
            tile.innerHTML += `<div class="bonus-label">${bonusType.label}</div>`;
        }

        gridEl.appendChild(tile);
    });
}
    
    function getRandomLetter() { return LETTER_BAG_STRING[Math.floor(Math.random() * LETTER_BAG_STRING.length)]; }
   
   function getRandomLetterSeeded(rng) {
    // This is the same logic, but uses our predictable 'rng' function
    return LETTER_BAG_STRING[Math.floor(rng() * LETTER_BAG_STRING.length)];
}
   
    function getBonusType() {
        const rand = Math.random();
        if (rand < 0.08) return { type: 'Time', label: '+5s', class: 'bonus-Time' };
        if (rand < 0.18) return { type: 'DW', label: 'DW', class: 'bonus-DW' };
        if (rand < 0.28) return { type: 'TL', label: 'TL', class: 'bonus-TL' };
        if (rand < 0.40) return { type: 'DL', label: 'DL', class: 'bonus-DL' };
        return null;
    }

    function getBonusTypeSeeded(rng) {
    // This is the same logic, but uses our predictable 'rng' function
    const rand = rng(); 
    if (rand < 0.18) return { type: 'DW', label: 'DW', class: 'bonus-DW' };
    if (rand < 0.28) return { type: 'TL', label: 'TL', class: 'bonus-TL' };
    if (rand < 0.40) return { type: 'DL', label: 'DL', class: 'bonus-DL' };
    return null;
}

async function getDailyPuzzleWithTimeout() {
    const startTime = Date.now();
    const timeout = 10000; // 10 seconds in milliseconds
    const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });

    while (Date.now() - startTime < timeout) {
        try {
            // First, try to get from cache
            const cachedPuzzleJSON = localStorage.getItem(`dailyPuzzle-${todayStr}`);
            if (cachedPuzzleJSON) {
                console.log("Loaded daily puzzle from cache.");
                return JSON.parse(cachedPuzzleJSON);
            }

            // If not in cache, try to get from Firestore
            if (db) {
                const puzzleRef = doc(db, "dailyPuzzles", todayStr);
                const docSnap = await getDoc(puzzleRef);
                if (docSnap.exists()) {
                    console.log("Fetched pre-made daily puzzle from Firestore.");
                    const puzzle = docSnap.data();
                    // Save to cache for next time
                    localStorage.setItem(`dailyPuzzle-${todayStr}`, JSON.stringify(puzzle));
                    return puzzle;
                }
            }
        } catch (e) {
            console.error("Error during puzzle fetch attempt:", e);
        }
        
        // If not found, wait 1.5 seconds before the next attempt
        await new Promise(resolve => setTimeout(resolve, 1500));
    }

    // If the while loop finishes, it means we timed out
    return null;
}

 async function startGame(practiceMode = false, gameMode = 'standard') {
    if (!db) {
        showGameMessage("Connecting...");
        return;
    }

    if (gameMode === 'daily') {
        const dailyButton = document.getElementById('play-daily-button');
        if (!dailyButton || dailyButton.disabled) return;
        const originalButtonHTML = dailyButton.innerHTML;
        dailyButton.disabled = true;
        dailyButton.innerHTML = `<div class="flex items-center justify-center"><svg class="animate-spin -ml-1 mr-3 h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span>Loading...</span></div>`;

        const puzzleData = await getDailyPuzzleWithTimeout();

        if (!puzzleData) {
            showGameMessage("Today's puzzle isn't ready. Please try again later.", "error");
            dailyButton.disabled = false;
            dailyButton.innerHTML = originalButtonHTML;
            return;
        }
        
        allDailyWords = new Set(puzzleData.allWords);
        const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        
        let hasCompleted = false;
        let finalSavedData = null;

        // ✅ 1. First, check Firebase ONLY to see if the challenge is already completed.
        if (db && userId) {
            const dailyDocRef = doc(db, `players/${userId}/dailyChallenges`, todayStr);
            try {
                const docSnap = await getDoc(dailyDocRef);
                if (docSnap.exists() && docSnap.data().completed === true) {
                    hasCompleted = true;
                    finalSavedData = docSnap.data();
                }
            } catch (e) { console.error("Error loading daily completion status from Firebase:", e); }
        }

        if (hasCompleted) {
            // If completed, show the end screen with final data from Firebase.
            const finalStats = { score: finalSavedData.score || 0, foundWords: finalSavedData.foundWords || [], totalCount: allDailyWords.size };
            showDailyEndScreen(finalStats, false);
            return;
        }

        // ✅ 2. If not completed, try to load the IN-PROGRESS game from Local Storage.
        try {
            const savedProgressJSON = localStorage.getItem(`dailyProgress-${todayStr}`);
            if (savedProgressJSON) {
                const savedData = JSON.parse(savedProgressJSON);
                score = savedData.score || 0;
                foundWords = savedData.foundWords || [];
                console.log("Loaded in-progress game from Local Storage.");
            } else {
                score = 0;
                foundWords = [];
            }
        } catch (e) {
            console.error("Failed to load progress from Local Storage:", e);
            score = 0;
            foundWords = [];
        }
        
        messageModal.classList.add('hidden');
        currentGamemode = 'daily';
        setupDailyUI({ ...puzzleData, allWords: allDailyWords });
        return;

    } else { // --- Standard & Practice Mode Logic ---
        document.getElementById('daily-challenge-content').style.display = 'none';
        gameContentEl.style.display = 'block';
        currentGamemode = practiceMode ? 'practice' : 'standard';
        isPracticeMode = practiceMode;
        menuContainer.classList.remove('hidden');
        clearInterval(timerInterval);
        score = 0;
        foundWords = [];
        updateScoreDisplay();
        if (isPracticeMode) {
            practiceTimeElapsed = 0;
            topLeftDisplayEl.innerHTML = `<div class="text-xs font-bold text-blue-500 uppercase tracking-wider">Pace</div><div id="pace-score" class="text-3xl font-black text-blue-400">0</div>`;
            updatePracticeUI();
            timerInterval = setInterval(() => { practiceTimeElapsed++; updatePracticeUI(); }, 1000);
        } else {
            const highScoreEl = document.getElementById('high-score');
            const currentHighScore = highScoreEl ? highScoreEl.textContent : '0';
            topLeftDisplayEl.innerHTML = `<div class="text-xs font-bold text-slate-500 uppercase tracking-wider">High</div><div id="high-score" class="text-3xl font-black text-slate-400">${currentHighScore}</div>`;
            timer = GAME_TIME;
            updateTimerUI();
            if (db) { 
                const statsRef = doc(db, "gameStats", "stats");
                setDoc(statsRef, { playCount: increment(1) }, { merge: true }).catch(console.warn);
            }
            timerInterval = setInterval(() => { timer--; updateTimerUI(); if (timer <= 0) endGame(); }, 1000);
        }
        messageModal.classList.add('hidden');
        clearInterval(animationInterval);
        activeGridEl = document.getElementById('grid');
        activeCanvasEl = document.getElementById('line-canvas');
        activeCtx = activeCanvasEl.getContext('2d');
        createGrid(generateAndValidateBoard(), activeGridEl);
        attachGridListeners(activeGridEl);
        activeGridEl.style.pointerEvents = 'auto';
    }
}

function resetGame() {
    clearInterval(timerInterval);
    endGameModal.classList.add('hidden');
    statsModal.classList.add('hidden');
    gameContentEl.style.display = 'none';
    document.getElementById('daily-challenge-content').style.display = 'none';
    score = 0;
    foundWords = [];
    updateScoreDisplay();

    const highScoreEl = document.getElementById('high-score');
    const currentHighScore = highScoreEl ? highScoreEl.textContent : '0';

    topLeftDisplayEl.innerHTML = `<div class="text-xs font-bold text-slate-500 uppercase tracking-wider">High</div><div id="high-score" class="text-3xl font-black text-slate-400">${currentHighScore}</div>`;
    
    showWelcomeScreen();
    // ✅ FIX: Manually re-fetch player stats to update the welcome screen
    if (userId) {
        fetchPlayerStats(userId);
    }
}

 // ✅ ADD THIS ENTIRE NEW FUNCTION
function attachGridListeners(gridEl) {
    if (!gridEl) return;

    const startInteraction = e => {
        e.preventDefault();
        isMouseDown = true;
        clearSelection();
        const tile = getTileFromEvent(e);
        handleInteraction(tile);
    };
    
    const moveInteraction = e => {
        if (!isMouseDown) return;
        e.preventDefault();
        const tile = getTileFromEvent(e);
        handleInteraction(tile);
    };

    const endInteraction = () => {
        if (!isMouseDown) return;
        submitWord();
        isMouseDown = false;
    };

    // Remove old listeners to prevent duplicates, then add new ones
    gridEl.removeEventListener('pointerdown', startInteraction);
    gridEl.removeEventListener('pointermove', moveInteraction);
    gridEl.removeEventListener('pointerup', endInteraction);
    gridEl.removeEventListener('pointerleave', endInteraction);

    gridEl.addEventListener('pointerdown', startInteraction);
    gridEl.addEventListener('pointermove', moveInteraction);
    gridEl.addEventListener('pointerup', endInteraction);
    gridEl.addEventListener('pointerleave', endInteraction);

    // Initial resize and setup listener for window resizing
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
}

function setupDailyUI(challengeData) {
    gameContentEl.style.display = 'none';
    const dailyChallengeContentEl = document.getElementById('daily-challenge-content');
    dailyChallengeContentEl.style.display = 'block';
    menuContainer.classList.remove('hidden');

    const totalWords = challengeData.allWords.size;
    const today = new Date();
    const dateString = `${today.getMonth() + 1}/${today.getDate()}/${String(today.getFullYear()).slice(-2)}`;
    
    dailyChallengeContentEl.innerHTML = `
        <div class="w-full max-w-sm mx-auto">
            <div class="flex items-center justify-between mb-3">
                <div class="flex-grow flex items-center justify-center">
                    <h1 class="text-3xl font-black text-slate-800 tracking-tighter flex items-center justify-center">
                        <img src="assets/word-worm-logo-icon.webp" alt="Word Worm Logo" class="w-9 h-9 mr-2" width="36" height="36">
                        <span>Word Worm</span>
                    </h1>
                </div>
            </div>
            
            <div class="bg-white rounded-xl shadow-md p-3 mb-3">
                <div class="flex items-center">
                    <div class="text-left">
                        <div class="text-xs font-bold text-slate-500">WORDS</div>
                        <div id="daily-word-count" class="text-3xl font-black text-slate-800">0 / ${totalWords}</div>
                    </div>
                    <div class="flex-1 text-center px-2">
                        <div class="text-xs font-bold text-slate-500">SCORE</div>
                        <div id="daily-score" class="text-3xl font-black text-amber-500">0</div>
                    </div>
                    <div class="text-right">
                        <button id="done-button" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-3 rounded-lg text-sm shadow-md flex items-center ml-auto">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor" class="w-4 h-4 mr-1.5"><path stroke-linecap="round" stroke-linejoin="round" d="m4.5 12.75 6 6 9-13.5" /></svg>
                            <span>Submit</span>
                        </button>
                    </div>
                </div>
                <div class="w-full bg-slate-200 rounded-full h-2 mt-2">
                    <div id="daily-progress-bar" class="bg-green-500 h-2 rounded-full" style="width: 0%;"></div>
                </div>
            </div>

            <div id="accordion-container" class="relative z-30 mb-3">
                <button id="accordion-trigger" class="w-full flex justify-between items-center p-3 bg-white rounded-xl shadow-md">
                    <div id="collapsed-view" class="flex-grow flex items-center gap-2 overflow-hidden pr-2">
                        <div id="instruction-text" class="text-xs text-slate-500 w-full pr-2"><strong>Daily Challenge (${dateString}):</strong> Find as many words as possible, then hit Submit when done!</div>
                        <div id="last-found-view" class="hidden flex-grow flex items-center gap-2 overflow-hidden">
                            <span class="text-xs font-bold text-slate-500 shrink-0">LAST FOUND:</span>
                            <div id="recent-words-display" class="flex gap-2 flex-nowrap"></div>
                        </div>
                    </div>
                    <div id="expanded-view" class="hidden flex-grow text-sm font-bold text-slate-700">
                        <span id="accordion-summary-text"></span>
                    </div>
                    <svg id="accordion-arrow" class="w-4 h-4 text-slate-500 shrink-0 transition-transform" fill="none" viewBox="0 0 24 24" stroke-width="3" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>
                </button>
                
                <div id="accordion-content" class="hidden absolute top-full left-0 w-full mt-1 bg-white shadow-lg rounded-xl p-4 border">
                    <div id="daily-found-words-list" class="flex flex-wrap gap-2 max-h-32 overflow-y-auto mb-4 pb-4 border-b"></div>
                    <div class="grid grid-cols-2 gap-x-4">
                        <div class="mb-4">
                            <div class="flex justify-between text-xs font-bold text-slate-500 mb-1">
                                <span>3-letter</span><span id="count-3">0/0</span>
                            </div>
                            <div class="w-full bg-slate-200 rounded-full h-2"><div id="progress-3" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div></div>
                        </div>
                        <div class="mb-4">
                            <div class="flex justify-between text-xs font-bold text-slate-500 mb-1">
                                <span>4-letter</span><span id="count-4">0/0</span>
                            </div>
                            <div class="w-full bg-slate-200 rounded-full h-2"><div id="progress-4" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div></div>
                        </div>
                        <div class="mb-4">
                            <div class="flex justify-between text-xs font-bold text-slate-500 mb-1">
                                <span>5-letter</span><span id="count-5">0/0</span>
                            </div>
                            <div class="w-full bg-slate-200 rounded-full h-2"><div id="progress-5" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div></div>
                        </div>
                        <div class="mb-4">
                            <div class="flex justify-between text-xs font-bold text-slate-500 mb-1">
                                <span>6-letter</span><span id="count-6">0/0</span>
                            </div>
                            <div class="w-full bg-slate-200 rounded-full h-2"><div id="progress-6" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div></div>
                        </div>
                    </div>
                    <div id="progress-7-container" class="hidden">
                        <div class="flex justify-between text-xs font-bold text-slate-500 mb-1">
                            <span>7-letter</span><span id="count-7">0/0</span>
                        </div>
                        <div class="w-full bg-slate-200 rounded-full h-2"><div id="progress-7" class="bg-green-500 h-2 rounded-full" style="width: 0%"></div></div>
                    </div>
                </div>
            </div>

            <div class="relative z-10">
                <canvas id="daily-line-canvas"></canvas>
                <div id="daily-grid" class="grid grid-cols-4 gap-2 select-none"></div>
            </div>
        </div>
    `;

    const accordionTrigger = dailyChallengeContentEl.querySelector('#accordion-trigger');
    const accordionContent = dailyChallengeContentEl.querySelector('#accordion-content');
    const accordionArrow = dailyChallengeContentEl.querySelector('#accordion-arrow');
    const collapsedView = dailyChallengeContentEl.querySelector('#collapsed-view');
    const expandedView = dailyChallengeContentEl.querySelector('#expanded-view');
    const doneButton = dailyChallengeContentEl.querySelector('#done-button');

    if(accordionTrigger) {
        accordionTrigger.addEventListener('click', () => {
            accordionContent.classList.toggle('hidden');
            accordionArrow.classList.toggle('rotate-180');
            collapsedView.classList.toggle('hidden');
            expandedView.classList.toggle('hidden');
        });
    }

    if (doneButton) {
        doneButton.addEventListener('click', showSubmitConfirmation);
    }

    activeGridEl = dailyChallengeContentEl.querySelector('#daily-grid');
    activeCanvasEl = dailyChallengeContentEl.querySelector('#daily-line-canvas');
    activeCtx = activeCanvasEl.getContext('2d');
    if (activeCanvasEl) {
        activeCanvasEl.style.position = 'absolute';
        activeCanvasEl.style.top = '0';
        activeCanvasEl.style.left = '0';
        activeCanvasEl.style.pointerEvents = 'none';
        activeCanvasEl.style.zIndex = '10';
    }
    createGrid(challengeData.board, activeGridEl, challengeData.bonuses);
    attachGridListeners(activeGridEl); 
    updateDailyChallengeUI(); 
}

    function endGame() {
    clearInterval(timerInterval);
    grid.style.pointerEvents = 'none';
    menuContainer.classList.add('hidden');
    
    // ✅ FIX: No delay needed. Show the end screen immediately.
    showEndGameScreen();

    if (analytics) {
        logEvent(analytics, 'game_end', {
            game_mode: isPracticeMode ? 'practice' : 'timed',
            final_score: score,
            words_found_count: foundWords.length,
            time_taken_seconds: isPracticeMode ? practiceTimeElapsed : GAME_TIME
        });
    }
    if (!isPracticeMode && db && userId) {
        processEndOfGame(score, foundWords, userId);
    }
}

function replaceSelectedTiles() {
    // ✅ FIX: Get the word that was just found so we can avoid re-creating it.
    const foundWordString = selectedTiles.map(t => t.dataset.letter).join('');

    let currentBoardLetters = Array.from(grid.children).map(t => t.dataset.letter);
    selectedTiles.forEach(tile => {
        const index = parseInt(tile.dataset.id);
        currentBoardLetters[index] = null;
    });

    // ✅ FIX: Pass the found word to the generator.
    const newBoard = generateAndValidateBoard(currentBoardLetters, isBoardPlayable, foundWordString);
    
    selectedTiles.forEach((tile) => {
        const index = parseInt(tile.dataset.id);
        const letter = newBoard[index];
        const points = letterConfig[letter].p;

        tile.dataset.bonus = '';
        tile.classList.remove('bonus-DL', 'bonus-TL', 'bonus-DW', 'bonus-Time');
        tile.style.transform = 'scale(0)';

        setTimeout(() => {
            tile.dataset.letter = letter;
            tile.dataset.points = points;
            tile.innerHTML = `<span>${letter}<sub class="text-xs font-semibold ml-1">${points}</sub></span>`;
            
            const bonusType = getBonusType();
            if (bonusType) {
                tile.dataset.bonus = bonusType.type;
                tile.classList.add(bonusType.class);
                tile.innerHTML += `<div class="bonus-label">${bonusType.label}</div>`;
            }

            tile.style.transform = 'scale(1)';
        }, 200);
    });
}
    
    function handleInteraction(tile) {
    if (!tile || !isMouseDown) return;
    
    const lastSelected = selectedTiles[selectedTiles.length - 1];

    if (selectedTiles.length > 1 && tile === selectedTiles[selectedTiles.length - 2]) {
        const lastTile = selectedTiles.pop();
        lastTile.classList.remove('selected');
    } else if (!selectedTiles.includes(tile) && (!lastSelected || isAdjacent(tile, lastSelected))) {
        selectedTiles.push(tile);
        tile.classList.add('selected');
    }

    updateCurrentWord();
    drawLines();
}
    
    function isAdjacent(t1, t2) {
        if (!t1 || !t2) return false;
        const id1 = parseInt(t1.dataset.id), id2 = parseInt(t2.dataset.id);
        const [c1, r1] = [id1 % GRID_COLS, Math.floor(id1 / GRID_COLS)];
        const [c2, r2] = [id2 % GRID_COLS, Math.floor(id2 / GRID_COLS)];
        return Math.abs(c1 - c2) <= 1 && Math.abs(r1 - r2) <= 1;
    }

  function submitWord() {
    const word = selectedTiles.map(t => t.dataset.letter).join('');
    
    // --- Daily Challenge Logic ---
    if (currentGamemode === 'daily') {
        const startTile = selectedTiles.length > 0 ? selectedTiles[0] : null;

        if (word.length < 3) {
            clearSelection();
            return;
        }
        if (!allDailyWords.has(word)) {
            showGameMessage("Not a valid word", "error", startTile);
            clearSelection();
            return;
        }
        if (foundWords.some(fw => fw.word === word)) {
            showGameMessage("Already Found!", "info", startTile);
            clearSelection();
            return;
        }
        
        let baseScore = 0;
        let wordMultiplier = 1;
        selectedTiles.forEach(tile => {
            let letterScore = parseInt(tile.dataset.points);
            switch (tile.dataset.bonus) {
                case 'DL': letterScore *= 2; break;
                case 'TL': letterScore *= 3; break;
                case 'DW': wordMultiplier *= 2; break;
            }
            baseScore += letterScore;
        });
        let finalScore = baseScore * wordMultiplier;
        if (word.length >= 7) finalScore += 40;
        else if (word.length === 6) finalScore += 20;
        else if (word.length === 5) finalScore += 10;
        else if (word.length === 4) finalScore += 5;

        foundWords.push({ word, score: finalScore, length: word.length });
        score += finalScore;
        
        updateDailyChallengeUI(); 
        
        saveDailyProgress();
        
        createFlyingScore(finalScore, selectedTiles[0]);
        triggerConfetti(selectedTiles);

    } else { // --- Standard & Practice Mode Logic ---
        if (word.length >= 3 && fullDictionaryTrie.search(word)) {
            let baseScore = 0; let wordMultiplier = 1; let timeBonus = 0;
            selectedTiles.forEach(tile => {
                let letterScore = parseInt(tile.dataset.points);
                switch(tile.dataset.bonus) {
                    case 'DL': letterScore *= 2; break; case 'TL': letterScore *= 3; break;
                    case 'DW': wordMultiplier *= 2; break; case 'Time': timeBonus += 5; break;
                }
                baseScore += letterScore;
            });

            let finalScore = baseScore * wordMultiplier;
            if (word.length >= 7) finalScore += 40;
            else if (word.length === 6) finalScore += 20;
            else if (word.length === 5) finalScore += 10;
            else if (word.length === 4) finalScore += 5;
            
            if (analytics) { logEvent(analytics, 'submit_word', { word_length: word.length, score: finalScore, game_mode: isPracticeMode ? 'practice' : 'timed' }); }
            if (timeBonus > 0 && !isPracticeMode) { timer += timeBonus; updateTimerUI(); }

            foundWords.push({ word, score: finalScore, length: word.length });
            createFlyingScore(finalScore, selectedTiles[0]);
            triggerConfetti(selectedTiles);
             score += finalScore;
            updateScoreDisplay();
            replaceSelectedTiles();
        }
    }
    
    clearSelection();
}

function updateDailyChallengeUI() {
    const dailyContent = document.getElementById('daily-challenge-content');
    if (!dailyContent || !allDailyWords) return;

    // --- References to UI elements ---
    const scoreEl = dailyContent.querySelector('#daily-score');
    const wordsEl = dailyContent.querySelector('#daily-word-count');
    const progressBar = dailyContent.querySelector('#daily-progress-bar');
    const summaryTextEl = dailyContent.querySelector('#accordion-summary-text'); 
    const instructionText = dailyContent.querySelector('#instruction-text');
    const lastFoundView = dailyContent.querySelector('#last-found-view');
    const recentWordsEl = dailyContent.querySelector('#recent-words-display'); 
    const collapsedView = dailyContent.querySelector('#collapsed-view');

    // --- Update main scoreboard ---
    if (scoreEl) scoreEl.textContent = score;
    if (wordsEl) wordsEl.textContent = `${foundWords.length} / ${allDailyWords.size}`;
    if (progressBar) {
        const progressPercent = allDailyWords.size > 0 ? (foundWords.length / allDailyWords.size) * 100 : 0;
        progressBar.style.width = `${progressPercent}%`;
    }

    // --- Update accordion trigger bar ---
    if (collapsedView) {
        collapsedView.style.minHeight = '24px';
    }
    if (foundWords.length > 0) {
        if (instructionText) instructionText.classList.add('hidden');
        if (lastFoundView) lastFoundView.classList.remove('hidden');
    } else {
        if (instructionText) instructionText.classList.remove('hidden');
        if (lastFoundView) lastFoundView.classList.add('hidden');
    }
    if(summaryTextEl) {
        const remaining = allDailyWords.size - foundWords.length;
        summaryTextEl.textContent = `You have ${remaining} words remaining!`;
    }
    
    if(recentWordsEl && lastFoundView) {
        const recent = [...foundWords].slice(-5).reverse();
        const container = recentWordsEl;
        container.innerHTML = '';

        lastFoundView.style.visibility = 'hidden';
        lastFoundView.classList.remove('hidden');

        for (const fw of recent) {
            const wordSpan = document.createElement('span');
            wordSpan.className = "bg-blue-100 text-blue-700 font-semibold text-xs px-2 py-0.5 rounded-md";
            wordSpan.textContent = fw.word.toUpperCase();
            container.appendChild(wordSpan);

            if (container.scrollWidth > container.clientWidth && container.clientWidth > 0) {
                wordSpan.remove();
                break;
            }
        }
        lastFoundView.style.visibility = 'visible';
        if (foundWords.length === 0) {
            lastFoundView.classList.add('hidden');
        }
    }
    
    // --- Update the accordion dropdown content ---
    const totalWordsByLength = { 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
    allDailyWords.forEach(word => {
        const len = word.length;
        if (len >= 3 && len <= 7) totalWordsByLength[len]++;
    });

    const foundWordsByLength = { 3: 0, 4: 0, 5: 0, 6: 0, 7: 0 };
    foundWords.forEach(fw => {
        const len = fw.word.length;
        if (len >= 3 && len <= 7) foundWordsByLength[len]++;
    });

    for (let len = 3; len <= 7; len++) {
        const countEl = dailyContent.querySelector(`#count-${len}`);
        const progressEl = dailyContent.querySelector(`#progress-${len}`);
        if (!countEl || !progressEl) continue;
        const foundCount = foundWordsByLength[len];
        const totalCount = totalWordsByLength[len];
        countEl.textContent = `${foundCount}/${totalCount}`;
        
        // ✅ FIX: If the total count is 0, make the bar 100% full (green).
        const percentage = totalCount > 0 ? (foundCount / totalCount) * 100 : 100;
        progressEl.style.width = `${percentage}%`;
    }
    
    const progress7Container = dailyContent.querySelector('#progress-7-container');
    if (progress7Container) {
        progress7Container.classList.toggle('hidden', totalWordsByLength[7] === 0);
    }

    const listEl = dailyContent.querySelector('#daily-found-words-list');
    if (listEl) {
        const sortedWords = [...foundWords].map(fw => fw.word).sort((a, b) => a.localeCompare(b));
        if (sortedWords.length > 0) {
            listEl.innerHTML = sortedWords.map(word => `<span class="bg-blue-100 text-blue-800 font-semibold text-xs px-2 py-0.5 rounded-md">${word.toUpperCase()}</span>`).join('');
        } else {
            listEl.innerHTML = `<p class="w-full text-center text-sm text-slate-400">You haven't found any words yet!</p>`;
        }
    }
}

async function endDailyChallenge() {
    if (activeGridEl) {
        activeGridEl.style.pointerEvents = 'none';
    }

    // This still submits the score to the public leaderboard
    await submitDailyScoreToLeaderboard(score);

    // This saves the final results to the player's personal profile in Firebase
    if (db && userId) {
        try {
            const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
            const dailyDocRef = doc(db, `players/${userId}/dailyChallenges`, todayStr);
            
            await setDoc(dailyDocRef, { 
                completed: true,
                score: score,
                foundWords: foundWords 
            }, { merge: true });
            
            // Clean up the local storage for today now that the game is submitted
            localStorage.removeItem(`dailyProgress-${todayStr}`);

        } catch (error) {
            console.error("Error finalizing daily challenge:", error);
        }
    }

    showDailyEndScreen({
        score: score,
        foundWords: foundWords,
        totalCount: allDailyWords.size,
    });
}

async function submitDailyScoreToLeaderboard(finalScore) {
    if (!db || !userId) {
        console.warn("Firebase not ready, can't submit daily score.");
        return;
    }
    const playerName = localStorage.getItem('wordRushPlayerName') || 'Anonymous';
    if (playerName === 'Anonymous') {
        console.log("Player is Anonymous, not submitting to daily leaderboard.");
        return;
    }

    const todayStr = new Date().toLocaleDateString('en-CA');
    const leaderboardRef = doc(db, "leaderboards", "dailyChallenge");

    const newScore = {
        userId: userId,
        name: playerName,
        score: finalScore,
        wordsFound: foundWords.length,
        totalWords: allDailyWords.size
    };

    try {
        await runTransaction(db, async (transaction) => {
            const leaderboardDoc = await transaction.get(leaderboardRef);
            
            // ✅ FIX: This logic is now simpler. It assumes the board has been reset by the server.
            const currentScores = leaderboardDoc.exists() ? leaderboardDoc.data().topScores : [];
            
            const filteredScores = currentScores.filter(s => s.userId !== userId);
            filteredScores.push(newScore);
            
            const newTopScores = filteredScores
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            transaction.set(leaderboardRef, { topScores: newTopScores, date: todayStr });
        });
        console.log("Daily score submitted successfully!");
    } catch (error) {
        console.error("Error submitting daily score:", error);
    }
}

function saveDailyProgress() {
    // This function is now synchronous and only saves to local storage.
    if (currentGamemode !== 'daily') return;
    try {
        const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        const progress = {
            score: score,
            foundWords: foundWords
        };
        localStorage.setItem(`dailyProgress-${todayStr}`, JSON.stringify(progress));
    } catch (e) {
        console.error("Error saving progress to Local Storage:", e);
    }
}

// ✅ ADD THIS ENTIRE NEW FUNCTION
function getTileFromEvent(e) {
    if (!tilePositions.length) return null;
    const x = e.clientX;
    const y = e.clientY;

    for (const tilePos of tilePositions) {
        const dx = x - tilePos.center.x;
        const dy = y - tilePos.center.y;
        if (Math.sqrt(dx * dx + dy * dy) < tilePos.hitRadius) {
            return tilePos.el;
        }
    }
    return null;
}
    
    function clearSelection() { selectedTiles.forEach(t => t.classList.remove('selected')); selectedTiles = []; updateCurrentWord(); drawLines(); }
    
   async function processEndOfGame(finalScore, words, uId) {
    if (!db || !uId || isPracticeMode) return;

    const playerDocRef = doc(db, "players", uId);
    const todayStr = new Date().toLocaleDateString('en-CA', { timeZone: 'America/New_York' });

    const gameData = {
        score: finalScore,
        timestamp: serverTimestamp(),
        words: words.map(w => ({ word: w.word, score: w.score, length: w.length }))
    };
    try {
        await addDoc(collection(db, `players/${uId}/games`), gameData);
    } catch(e) { console.error("Failed to save game history:", e); }

    const { updatedStats, didBeatDailyHighScore } = await runTransaction(db, async (transaction) => {
        const playerDoc = await transaction.get(playerDocRef);
        const oldData = playerDoc.exists() ? playerDoc.data() : {};
        const yesterday = new Date();
        yesterday.setDate(yesterday.getDate() - 1);
        const yesterdayStr = yesterday.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        let newPlayStreak = 1;
        if (oldData.lastPlayDate === yesterdayStr) newPlayStreak = (oldData.playStreak || 0) + 1;
        else if (oldData.lastPlayDate === todayStr) newPlayStreak = oldData.playStreak || 1;

        let dailyHighScoreBeaten = false;
        let newDailyHighScoreForProfile = finalScore;
        if (oldData.dailyHighScoreLastUpdated === todayStr) {
            if(finalScore > (oldData.dailyHighScore || 0)) {
                dailyHighScoreBeaten = true;
            } else {
                newDailyHighScoreForProfile = oldData.dailyHighScore;
            }
        } else {
            dailyHighScoreBeaten = true;
        }

        const newHighScore = Math.max(finalScore, oldData.highScore || 0);
        const gameBestWord = words.length > 0 ? words.reduce((best, current) => current.score > best.score ? current : best, { score: 0, word: '' }) : { score: 0, word: '' };
        const newBestWordForProfile = gameBestWord.score > (oldData.bestWord?.score || 0) ? { word: gameBestWord.word, score: gameBestWord.score } : (oldData.bestWord || { word: '', score: 0 });
        const lettersThisGame = words.reduce((sum, w) => sum + w.length, 0);
        const newTop5Scores = [...(oldData.top5Scores || []), { score: finalScore, date: todayStr }].sort((a,b)=>b.score-a.score).slice(0,5);
        const newTop5LongestWords = [...new Map([...(oldData.top5LongestWords || []), ...words.map(w=>({word:w.word,length:w.length}))].map(item=>[item.word,item])).values()].sort((a,b)=>b.length-a.length).slice(0,5);
        
        const updateData = {
            totalGamesPlayed: increment(1),
            totalPoints: increment(finalScore),
            lastPlayed: serverTimestamp(),
            highScore: newHighScore,
            bestWord: newBestWordForProfile,
            totalWordsFound: increment(words.length),
            totalLettersFound: increment(lettersThisGame),
            top5Scores: newTop5Scores,
            top5LongestWords: newTop5LongestWords,
            dailyHighScore: newDailyHighScoreForProfile,
            dailyHighScoreLastUpdated: todayStr,
            playStreak: newPlayStreak,
            lastPlayDate: todayStr,
            name: oldData.name || localStorage.getItem('wordRushPlayerName') || 'Anonymous',
            hasSubmittedName: oldData.hasSubmittedName || false
        };
        const fullUpdatedData = { ...oldData, ...updateData, totalGamesPlayed: (oldData.totalGamesPlayed || 0) + 1, totalPoints: (oldData.totalPoints || 0) + finalScore, totalWordsFound: (oldData.totalWordsFound || 0) + words.length, totalLettersFound: (oldData.totalLettersFound || 0) + lettersThisGame, };
        if (playerDoc.exists()) { transaction.update(playerDocRef, updateData); } else { transaction.set(playerDocRef, updateData); }
        return { updatedStats: fullUpdatedData, didBeatDailyHighScore: dailyHighScoreBeaten };
    });

    let finalPlayerName = updatedStats.name;
    if (!updatedStats.hasSubmittedName || updatedStats.name === 'Anonymous') {
        const submissionContainer = document.getElementById('submission-container');
        // This replaces the spinner with the input form
        submissionContainer.innerHTML = `<div id="submit-score-form" class="w-full"><div class="flex space-x-2"><input type="text" id="player-name" placeholder="Enter your name" class="w-full px-3 py-2 border border-slate-300 rounded-lg" maxlength="10"><button id="submit-global-score" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">Submit</button></div></div>`;
        
         // ✅ FIX: Only pre-fill the name if it's saved and not 'Anonymous'.
        // Otherwise, leave it blank for the placeholder text to show.
        const savedName = localStorage.getItem('wordRushPlayerName');
        if (savedName && savedName !== 'Anonymous') {
            nameInput.value = savedName;
        }

        await new Promise(resolve => {
            document.getElementById('submit-global-score').onclick = async (e) => {
                // ✅ FIX: Revert to the simple button disable logic.
                const button = e.target;
                button.disabled = true;
                button.innerHTML = '...';

                const newPlayerName = nameInput.value.trim();
                if (newPlayerName) {
                    finalPlayerName = newPlayerName;
                    localStorage.setItem('wordRushPlayerName', finalPlayerName);
                    await setDoc(playerDocRef, { name: finalPlayerName, hasSubmittedName: true }, { merge: true });
                    updatedStats.name = finalPlayerName;
                    resolve();
                } else {
                    button.disabled = false;
                    button.innerHTML = 'Submit';
                }
            }
        });
    }
    
    // --- Update Timed Daily Leaderboard ---
    let dailyRank = null;
    const dailyRef = doc(db, "leaderboards", "daily");
    try {
        await runTransaction(db, async (transaction) => {
            const leaderboardDoc = await transaction.get(dailyRef);
            let data = leaderboardDoc.exists() ? leaderboardDoc.data() : { topByHighScore: [], topByTotalScore: [], topByBestWord: [] };
            const oldTotalEntry = (data.topByTotalScore || []).find(e => e.userID === uId);
            const oldBestWordEntry = (data.topByBestWord || []).find(e => e.userID === uId);
            const gameBestWord = words.length > 0 ? words.reduce((best, current) => current.score > best.score ? current : best, { score: 0, word: '' }) : { score: 0, word: '' };
            const newTotalScore = (oldTotalEntry?.dailyTotalScore || 0) + finalScore;
            const newBestWord = gameBestWord.score > (oldBestWordEntry?.dailyBestWord?.score || 0) ? gameBestWord : (oldBestWordEntry?.dailyBestWord || gameBestWord);
            data.topByHighScore = updateLeaderboardList(data.topByHighScore || [], { userID: uId, name: finalPlayerName, dailyHighScore: updatedStats.dailyHighScore }, 'dailyHighScore');
            data.topByTotalScore = updateLeaderboardList(data.topByTotalScore || [], { userID: uId, name: finalPlayerName, dailyTotalScore: newTotalScore }, 'dailyTotalScore');
            data.topByBestWord = updateLeaderboardList(data.topByBestWord || [], { userID: uId, name: finalPlayerName, dailyBestWord: newBestWord }, 'dailyBestWord', 'score');
            transaction.set(dailyRef, data);
        });
        
        // ✅ FIX: After the transaction, read the leaderboard back to find the player's new rank.
        const updatedLeaderboardDoc = await getDoc(dailyRef);
        if (updatedLeaderboardDoc.exists()) {
            const topHighScores = updatedLeaderboardDoc.data().topByHighScore || [];
            const rankIndex = topHighScores.findIndex(p => p.userID === uId);
            if (rankIndex !== -1) {
                dailyRank = rankIndex + 1; // It's 0-indexed, so add 1
            }
        }
    } catch (e) { console.error("Failed to update daily (timed) leaderboard:", e); }
    
    // --- Update All-Time Leaderboard ---
    const allTimeRef = doc(db, "leaderboards", "allTime");
    try {
        await runTransaction(db, async (transaction) => {
            const allTimeDoc = await transaction.get(allTimeRef);
            let data = allTimeDoc.exists() ? allTimeDoc.data() : { topByHighScore: [], topByTotalPoints: [], topByBestWord: [] };
            data.topByHighScore = updateLeaderboardList(data.topByHighScore, { userID: uId, name: finalPlayerName, score: updatedStats.highScore }, 'score');
            data.topByTotalPoints = updateLeaderboardList(data.topByTotalPoints, { userID: uId, name: finalPlayerName, totalPoints: updatedStats.totalPoints }, 'totalPoints');
            data.topByBestWord = updateLeaderboardList(data.topByBestWord, { userID: uId, name: finalPlayerName, bestWord: updatedStats.bestWord }, 'bestWord', 'score');
            transaction.set(allTimeRef, data);
        });
    } catch(e) { console.error("Failed to update all-time leaderboard:", e); }
    
    // ✅ FIX: Pass the newly calculated rank to the UI update function.
    updateEndGameSubmissionUI(finalPlayerName, { didBeatDailyHighScore, rank: dailyRank });
}
    
    function updateScoreDisplay() {
        scoreEl.textContent = score;
        scoreEl.classList.add('animate-pulse');
        scoreEl.addEventListener('animationend', () => scoreEl.classList.remove('animate-pulse'), { once: true });
        if (!isPracticeMode) {
            const highScoreEl = document.getElementById('high-score');
            const currentHighScore = parseInt(highScoreEl.textContent) || 0;
            if (score > currentHighScore) { 
                highScoreEl.textContent = score; 
                highScoreEl.classList.add('text-yellow-500', 'animate-pulse');
            }
        } else {
            updatePracticeUI();
        }
    }

    function updateTimerUI() {
    timerEl.textContent = timer;
    // Remove all potential timer classes
    timerEl.classList.remove('text-green-500', 'text-yellow-500', 'text-red-500', 'timer-warning');

    if (timer <= 10) {
        // Add the red text color and the new glowing pulse animation
        timerEl.classList.add('text-red-500', 'timer-warning');
    } else if (timer <= 30) {
        timerEl.classList.add('text-yellow-500');
    } else {
        timerEl.classList.add('text-green-500');
    }
}
    
    function updatePracticeUI() {
        const minutes = Math.floor(practiceTimeElapsed / 60);
        const seconds = practiceTimeElapsed % 60;
        timerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

        timerEl.classList.remove('text-yellow-500', 'text-red-500', 'animate-pulse', 'timer-warning');

        timerEl.classList.add('text-green-500');
        
        const pace = Math.round((score / Math.max(1, practiceTimeElapsed)) * 60);
        const paceScoreEl = document.getElementById('pace-score');
        if (paceScoreEl) {
            paceScoreEl.textContent = isNaN(pace) ? 0 : pace;
        }
    }

function triggerConfetti(tiles) {
    tiles.forEach(tile => {
        const rect = tile.getBoundingClientRect();
        for (let i = 0; i < 10; i++) {
            const p = document.createElement('div');
            p.className = 'particle';
            const angle = Math.random() * Math.PI * 2,
                dist = Math.random() * 40 + 20;
            p.style.setProperty('--transform-end', `translate(${Math.cos(angle)*dist}px,${Math.sin(angle)*dist}px)`);
            p.style.left = `${rect.left+rect.width/2-4}px`;
            p.style.top = `${rect.top+rect.height/2-4}px`;
            document.body.appendChild(p);
            setTimeout(() => p.remove(), 1200);
        }
    });
}

   function triggerEndGameConfetti(originEl) {
    // ✅ FIX: If no specific element is provided, do nothing.
    // This prevents accidental, un-centered confetti.
    if (!originEl) return;

    const rect = originEl.getBoundingClientRect();
    const originX = rect.left + rect.width / 2;
    const originY = rect.top + rect.height / 2;

    for (let i = 0; i < 60; i++) {
        const p = document.createElement('div');
        p.className = 'particle';
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * 120 + 50; 
        p.style.setProperty('--transform-end', `translate(${Math.cos(angle) * dist}px, ${Math.sin(angle) * dist}px)`);
        p.style.left = `${originX - 4}px`;
        p.style.top = `${originY - 4}px`;
        const colors = ['#facc15', '#f59e0b', '#60a5fa', '#3b82f6', '#22c55e'];
        p.style.background = colors[Math.floor(Math.random() * colors.length)];
        document.body.appendChild(p);
        setTimeout(() => p.remove(), 1200);
    }
}
    
   function createFlyingScore(points, startTile) {
    const scale = 1; // All popups are now the same size
    let vibrationIntensity = 0;
    let colorGradient = 'linear-gradient(45deg, #facc15, #f59e0b)'; // Default yellow for scores <= 10

    // Set vibration and redness based on score tier
    if (points > 100) {
        vibrationIntensity = 5;
        colorGradient = 'linear-gradient(45deg, #b91c1c, #7f1d1d)'; // Darkest "full" red
    } else if (points > 50) {
        vibrationIntensity = 3.5;
        colorGradient = 'linear-gradient(45deg, #dc2626, #b91c1c)'; // Darker red
    } else if (points > 30) {
        vibrationIntensity = 2.5;
        colorGradient = 'linear-gradient(45deg, #ef4444, #dc2626)'; // Medium red
    } else if (points > 10) {
        vibrationIntensity = 1.5;
        colorGradient = 'linear-gradient(45deg, #fca5a5, #ef4444)'; // Light red
    }

    const rect = startTile.getBoundingClientRect();

    // 1. Create the outer wrapper that will fly up
    const wrapper = document.createElement('div');
    wrapper.style.position = 'absolute';
    wrapper.style.left = `${rect.left}px`;
    wrapper.style.top = `${rect.top}px`;
    wrapper.style.zIndex = '100';
    wrapper.style.pointerEvents = 'none';
    wrapper.style.animation = 'fly-to-score 1.5s ease-in-out forwards';

    // 2. Create the inner score element that will vibrate
    const el = document.createElement('div');
    el.className = 'flying-score';
    el.style.animation = 'none';
    el.textContent = `+${points}`;
    el.style.position = 'static';
    el.style.transform = `scale(${scale})`; // Apply the standard scale
    el.style.background = colorGradient; // Apply the tiered color

    // 3. Append and start the animation
    wrapper.appendChild(el);
    document.body.appendChild(wrapper);

    // If vibration is needed, start the vibration loop on the inner element
    if (vibrationIntensity > 0) {
        let animationFrameId;
        const vibrate = () => {
            const x = (Math.random() - 0.5) * vibrationIntensity;
            const y = (Math.random() - 0.5) * vibrationIntensity;
            el.style.transform = `scale(${scale}) translate(${x}px, ${y}px)`;
            animationFrameId = requestAnimationFrame(vibrate);
        };
        vibrate();
        setTimeout(() => cancelAnimationFrame(animationFrameId), 1300);
    }

    // Remove the entire wrapper after the animation is complete
    setTimeout(() => wrapper.remove(), 1500);
}

function updateCurrentWord() {
    const newWordHTML = selectedTiles.map(t => `<span class="current-letter bg-white text-blue-500 font-bold text-xl p-1 rounded-md shadow-sm">${t.dataset.letter}</span>`).join('');
    
    // ✅ FIX: Only update the display if the word has actually changed. This prevents the flicker.
    if (currentWordLettersEl.innerHTML !== newWordHTML) {
        currentWordLettersEl.innerHTML = newWordHTML;
    }
}

function updateLeaderboardList(list, newEntry, sortKey, nestedKey = null) {
    const filteredList = list.filter(item => item.userID !== newEntry.userID);
    const newList = [...filteredList, newEntry];
    
    newList.sort((a, b) => {
        const valA = nestedKey ? (a[sortKey] || {})[nestedKey] || 0 : a[sortKey] || 0;
        const valB = nestedKey ? (b[sortKey] || {})[nestedKey] || 0 : b[sortKey] || 0;
        return valB - valA;
    });

    return newList.slice(0, 10);
}

   function showWelcomeScreen() {
    modalContent.innerHTML = `
        <div class="bg-white rounded-2xl shadow-lg p-6 text-center">
            <h1 class="text-4xl font-black text-slate-800 tracking-tighter mb-1 flex items-center justify-center">
                <img src="assets/word-worm-logo-icon.webp" alt="Word Worm Logo" class="w-12 h-12 mr-2" width="48" height="48">
                <span>Word Worm</span>
            </h1>
            <p class="text-slate-500 text-sm mb-3">The fast-paced word finding game!</p>
            
<div id="how-to-play-container" class="relative bg-slate-100 p-3 rounded-lg h-[17rem] flex flex-col"></div>

     <div class="flex items-center gap-3 mt-4">
    <button id="play-daily-button" class="bg-blue-500 hover:bg-blue-600 flex-1 text-white font-bold h-12 px-2 rounded-lg text-sm shadow-lg flex items-center justify-center transition-transform hover:scale-105">
        <div class="flex items-center justify-center">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-2">
        <path stroke-linecap="round" stroke-linejoin="round" d="M14.25 6.087c0-.355.186-.676.401-.959.221-.29.349-.634.349-1.003 0-1.036-1.007-1.875-2.25-1.875s-2.25.84-2.25 1.875c0 .369.128.713.349 1.003.215.283.401.604.401.959v0a.64.64 0 0 1-.657.643 48.39 48.39 0 0 1-4.163-.3c.186 1.613.293 3.25.315 4.907a.656.656 0 0 1-.658.663v0c-.355 0-.676-.186-.959-.401a1.647 1.647 0 0 0-1.003-.349c-1.036 0-1.875 1.007-1.875 2.25s.84 2.25 1.875 2.25c.369 0 .713-.128 1.003-.349.283-.215.604-.401.959-.401v0c.31 0 .555.26.532.57a48.039 48.039 0 0 1-.642 5.056c1.518.19 3.058.309 4.616.354a.64.64 0 0 0 .657-.643v0c0-.355-.186-.676-.401-.959a1.647 1.647 0 0 1-.349-1.003c0-1.035 1.008-1.875 2.25-1.875 1.243 0 2.25.84 2.25 1.875 0 .369-.128.713-.349 1.003-.215.283-.4.604-.4.959v0c0 .333.277.599.61.58a48.1 48.1 0 0 0 5.427-.63 48.05 48.05 0 0 0 .582-4.717.532.532 0 0 0-.533-.57v0c-.355 0-.676.186-.959.401-.29.221-.634.349-1.003.349-1.035 0-1.875-1.007-1.875-2.25s.84-2.25 1.875-2.25c.37 0 .713.128 1.003.349.283.215.604.401.96.401v0a.656.656 0 0 0 .658-.663 48.422 48.422 0 0 0-.37-5.36c-1.886.342-3.81.574-5.766.689a.578.578 0 0 1-.61-.58v0Z" />
        </svg>
            <span>Daily Challenge</span>
        </div>
    </button>
    <button id="play-game-mode-button" class="bg-green-500 hover:bg-green-600 flex-1 text-white font-bold h-12 px-2 rounded-lg text-base shadow-lg flex items-center justify-center transition-transform hover:scale-105">
        <div class="flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M15.59 14.37a6 6 0 0 1-5.84 7.38v-4.8m5.84-2.58a14.98 14.98 0 0 0 6.16-12.12A14.98 14.98 0 0 0 9.631 8.41m5.96 5.96a14.926 14.926 0 0 1-5.841 2.58m-.119-8.54a6 6 0 0 0-7.381 5.84h4.8m2.581-5.84a14.927 14.927 0 0 0-2.58 5.84m2.699 2.7c-.103.021-.207.041-.311.06a15.09 15.09 0 0 1-2.448-2.448 14.9 14.9 0 0 1 .06-.312m-2.24 2.39a4.493 4.493 0 0 0-1.757 4.306 4.493 4.493 0 0 0 4.306-1.758M16.5 9a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0Z" /></svg>
            <span>Play</span>
        </div>
    </button>
</div>
            
            <div class="bg-slate-100 rounded-xl p-2 mt-4">
                <div class="grid grid-cols-3 gap-1 text-center">
                    <div class="bg-white rounded-lg shadow-sm p-1 flex flex-col items-center justify-center">
                    <div id="welcome-high-score" class="h-7 flex items-center justify-center text-xl font-black text-amber-500">0</div>                        <div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider">Your High</div>
                    </div>
                
                    <a href="#" id="welcome-stats-button" class="bg-white rounded-lg shadow-sm p-1 flex flex-col items-center justify-center hover:bg-slate-50 transition-colors">
                        <div class="h-7 flex items-center justify-center text-blue-500">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z" /></svg>
                        </div>
                        <div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider">Your Stats</div>
                    </a>
                
                    <a href="#" id="welcome-leaderboard-button" class="bg-white rounded-lg shadow-sm p-1 flex flex-col items-center justify-center hover:bg-slate-50 transition-colors">
                        <div class="h-7 flex items-center justify-center text-green-500">
                             <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="m6.115 5.19.319 1.913A6 6 0 0 0 8.11 10.36L9.75 12l-.387.775c-.217.433-.132.956.21 1.298l1.348 1.348c.21.21.329.497.329.795v1.089c0 .426.24.815.622 1.006l.153.076c.433.217.956.132 1.298-.21l.723-.723a8.7 8.7 0 0 0 2.288-4.042 1.087 1.087 0 0 0-.358-1.099l-1.33-1.108c-.251-.21-.582-.299-.905-.245l-1.17.195a1.125 1.125 0 0 1-.98-.314l-.295-.295a1.125 1.125 0 0 1 0-1.591l.13-.132a1.125 1.125 0 0 1 1.3-.21l.603.302a.809.809 0 0 0 1.086-1.086L14.25 7.5l1.256-.837a4.5 4.5 0 0 0 1.528-1.732l.146-.292M6.115 5.19A9 9 0 1 0 17.18 4.64M6.115 5.19A8.965 8.965 0 0 1 12 3c1.929 0 3.716.607 5.18 1.64" /></svg>
                        </div>
                        <div class="text-[10px] font-bold text-slate-500 uppercase tracking-wider">Leaderboard</div>
                    </a>
                </div>
                <div class="border-t border-slate-200 mt-2 pt-2">
                    <p id="player-greeting" class="text-xs text-slate-600 font-medium"></p>
                </div>
            </div>

            <div class="text-center text-xs text-slate-400 mt-4">
  <p>&copy; 2025 Word Worm</p>
  <p>
    <a href="/about.html" class="hover:underline">About</a> &bull;
    <a href="/contact.html" class="hover:underline">Contact</a> &bull;
    <a href="/privacy.html" class="hover:underline">Privacy Policy</a> &bull;
    <a href="/terms.html" class="hover:underline">Terms of Use</a>
  </p>
</div>
        </div>
    `;

    menuContainer.classList.add('hidden');
    messageModal.classList.remove('hidden');
    
    document.getElementById('welcome-stats-button').onclick = (e) => {
        e.preventDefault();
        showStatsModal();
    };
    document.getElementById('welcome-leaderboard-button').onclick = (e) => {
        e.preventDefault();
        showLeaderboardModal();
    };

    setupTutorial();
    menuContainer.classList.add('hidden');
    
    document.getElementById('play-game-mode-button').onclick = () => startGame(false);
    document.getElementById('play-practice-button').onclick = () => startGame(true);
    document.getElementById('play-daily-button').onclick = () => startGame(false, 'daily');
}

   async function showLeaderboardModal() {
    leaderboardModal.classList.remove('hidden');
    leaderboardModalContent.innerHTML = `
        <div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-xs mx-auto modal-enter">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold text-slate-800 flex items-center">
                    Leaderboard 
                    <span class="inline-block w-6 h-6 ml-2">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="m6.115 5.19.319 1.913A6 6 0 0 0 8.11 10.36L9.75 12l-.387.775c-.217.433-.132.956.21 1.298l1.348 1.348c.21.21.329.497.329.795v1.089c0 .426.24.815.622 1.006l.153.076c.433.217.956.132 1.298-.21l.723-.723a8.7 8.7 0 0 0 2.288-4.042 1.087 1.087 0 0 0-.358-1.099l-1.33-1.108c-.251-.21-.582-.299-.905-.245l-1.17.195a1.125 1.125 0 0 1-.98-.314l-.295-.295a1.125 1.125 0 0 1 0-1.591l.13-.132a1.125 1.125 0 0 1 1.3-.21l.603.302a.809.809 0 0 0 1.086-1.086L14.25 7.5l1.256-.837a4.5 4.5 0 0 0 1.528-1.732l.146-.292M6.115 5.19A9 9 0 1 0 17.18 4.64M6.115 5.19A8.965 8.965 0 0 1 12 3c1.929 0 3.716.607 5.18 1.64" /></svg>
                    </span>
                </h2>
                <button id="close-leaderboard-button" class="text-3xl leading-none text-slate-400 hover:text-slate-800">&times;</button>
            </div>
            <div class="flex p-1 bg-slate-200 rounded-lg mb-4">
                <button id="challenge-tab" class="tab-button flex-1 py-1 px-2 rounded-md font-semibold text-sm transition-colors duration-200">Challenge</button>
                <button id="daily-tab" class="tab-button flex-1 py-1 px-2 rounded-md font-semibold text-sm transition-colors duration-200">Daily</button>
                <button id="all-time-tab" class="tab-button flex-1 py-1 px-2 rounded-md font-semibold text-sm transition-colors duration-200">All-Time</button>
            </div>
            <div id="leaderboard-loading-secondary" class="text-slate-500 p-2">Fetching Scores...</div>
            <div id="leaderboard-scroll-container" class="relative max-h-[20rem] overflow-y-auto">
                <div id="leaderboard-list-simple" class="space-y-2 text-left"></div>
            </div>
        </div>`;

    const challengeTab = document.getElementById('challenge-tab');
    const dailyTab = document.getElementById('daily-tab');
    const allTimeTab = document.getElementById('all-time-tab');
    const listEl = document.getElementById('leaderboard-list-simple');
    const loadingEl = document.getElementById('leaderboard-loading-secondary');
    
    const displayTab = (type) => {
        if (!db) { listEl.innerHTML = `<p class="text-red-500 text-center p-4">Leaderboard is offline.</p>`; if (loadingEl) loadingEl.style.display = 'none'; return; }
        
        challengeTab.classList.remove('active');
        dailyTab.classList.remove('active'); 
        allTimeTab.classList.remove('active');

        // ✅ FIX: Added logic to handle the new 'challenge' type
        if(type === 'challenge') {
            challengeTab.classList.add('active');
            fetchAndDisplayLeaderboard('challenge', listEl, loadingEl);
        } else if(type === 'daily') {
            dailyTab.classList.add('active');
            fetchAndDisplayLeaderboard('daily', listEl, loadingEl);
        } else {
            allTimeTab.classList.add('active');
            fetchAndDisplayLeaderboard('all-time', listEl, loadingEl);
        }
    };

    challengeTab.onclick = () => displayTab('challenge');
    dailyTab.onclick = () => displayTab('daily');
    allTimeTab.onclick = () => displayTab('all-time');
    
    // Default to showing the 'Challenge' leaderboard first
    displayTab('challenge'); 
    
    document.getElementById('close-leaderboard-button').onclick = () => { leaderboardModal.classList.add('hidden'); };
}

    async function showStatsModal() {
        statsModal.classList.remove('hidden');
        statsModalContent.innerHTML = `<div class="bg-white rounded-2xl shadow-2xl p-6 text-center modal-enter"><h2 class="text-2xl font-bold text-slate-800 mb-4">Loading Your Stats...</h2><div class="animate-spin rounded-full h-12 w-12 border-b-2 border-slate-900 mx-auto"></div></div>`;
        
        const stats = await fetchAndCalculateStats();
        let statsHTML;
        if (stats) {
            const avgScore = stats.totalGamesPlayed > 0 ? Math.round(stats.totalPoints / stats.totalGamesPlayed) : 0;
            const avgWordLength = stats.totalWordsFound > 0 ? (stats.totalLettersFound / stats.totalWordsFound).toFixed(1) : 0;
            const playStreakIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"><path stroke-linecap="round" stroke-linejoin="round" d="M15.362 5.214A8.252 8.252 0 0 1 12 21 8.25 8.25 0 0 1 6.038 7.047 8.287 8.287 0 0 0 9 9.601a8.983 8.983 0 0 1 3.361-6.867 8.21 8.21 0 0 0 3 2.48Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M12 18a3.75 3.75 0 0 0 .495-7.468 5.99 5.99 0 0 0-1.925 3.547 5.975 5.975 0 0 1-2.133-1.001A3.75 3.75 0 0 0 12 18Z" /></svg>`;
            const totalPointsIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 0 0 6 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0 1 18 16.5h-2.25m-7.5 0h7.5m-7.5 0-1 3m8.5-3 1 3m0 0 .5 1.5m-.5-1.5h-9.5m0 0-.5 1.5m.75-9 3-3 2.148 2.148A12.061 12.061 0 0 1 16.5 7.605" /></svg>`;
            const bestWordIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>`;
            const bestWordDisplay = stats.bestWord.word ? `${stats.bestWord.word.toUpperCase()} (${stats.bestWord.score})` : 'N/A';
            const topScoresHTML = stats.top5Scores.map((s, i) => {
                const dateParts = s.date.split('-');
                const shortDate = `${Number(dateParts[1])}/${Number(dateParts[2])}/${dateParts[0].slice(-2)}`;
                return `<li class="flex justify-between p-1 ${i % 2 === 0 ? 'bg-slate-50' : ''} rounded"><span><strong>${s.score}</strong></span><span class="text-slate-500">${shortDate}</span></li>`;
            }).join('') || '<p class="text-xs text-slate-400 text-center py-1">No scores yet.</p>';
            const topWordsHTML = stats.top5LongestWords.map((w, i) => `<li class="p-1 ${i % 2 === 0 ? 'bg-slate-50' : ''} rounded"><strong>${w.word.toUpperCase()}</strong> (${w.length})</li>`).join('') || '<p class="text-xs text-slate-400 text-center py-1">No words found.</p>';
            statsHTML = `<div class="bg-white rounded-2xl shadow-2xl p-6 modal-enter w-full max-w-sm mx-auto max-h-[90vh] overflow-y-auto"> <div class="flex justify-between items-center mb-4"> <h2 class="text-2xl font-bold text-slate-800">Your Stats</h2> <button id="close-stats-button" class="text-3xl leading-none text-slate-400 hover:text-slate-800">&times;</button> </div> <div class="space-y-3 text-left mb-4"> <div class="flex items-center justify-between"><span class="flex items-center font-bold text-slate-600">${playStreakIcon}<span class="ml-2">Play Streak</span></span> <span class="font-black text-xl text-amber-500">${stats.playStreak} Day${stats.playStreak !== 1 ? 's' : ''}</span></div> <div class="flex items-center justify-between"><span class="flex items-center font-bold text-slate-600">${totalPointsIcon}<span class="ml-2">Total Points</span></span> <span class="font-black text-xl text-slate-700">${stats.totalPoints.toLocaleString()}</span></div> <div class="flex items-center justify-between"><span class="flex items-center font-bold text-slate-600">${bestWordIcon}<span class="ml-2">Best Word</span></span> <span class="font-black text-xl text-slate-700">${bestWordDisplay}</span></div> </div> <div class="grid grid-cols-3 gap-2 text-center bg-slate-100 p-3 rounded-lg mb-4"> <div><div class="text-xs font-bold text-slate-500 uppercase">Games</div><div class="text-2xl font-black text-slate-800">${stats.totalGamesPlayed}</div></div> <div><div class="text-xs font-bold text-slate-500 uppercase">Avg Score</div><div class="text-2xl font-black text-slate-800">${avgScore}</div></div> <div><div class="text-xs font-bold text-slate-500 uppercase">Avg Length</div><div class="text-2xl font-black text-slate-800">${avgWordLength}</div></div> </div> <div class="grid grid-cols-2 gap-4"> <div><h3 class="text-base font-bold text-slate-700 mb-2 border-b pb-1">Best Scores</h3><ol class="space-y-1">${topScoresHTML}</ol></div> <div><h3 class="text-base font-bold text-slate-700 mb-2 border-b pb-1">Longest Words</h3><ol class="space-y-1">${topWordsHTML}</ol></div> </div> </div>`;
        } else {
            statsHTML = `<div class="bg-white rounded-2xl shadow-2xl p-6 modal-enter w-full max-w-sm mx-auto"><div class="flex justify-between items-center mb-4"><h2 class="text-2xl font-bold text-slate-800">Your Stats</h2><button id="close-stats-button" class="text-3xl leading-none text-slate-400 hover:text-slate-800">&times;</button></div><p class="text-slate-500 text-center py-8">Play a game to see your stats here!</p></div>`;
        }
        statsModalContent.innerHTML = statsHTML;
        const closeButton = document.getElementById('close-stats-button');
        if (closeButton) {
            closeButton.onclick = () => { statsModal.classList.add('hidden'); };
        }
    }
    
    async function fetchAndCalculateStats() {
        if (!db || !userId) return null;
        const playerDocRef = doc(db, "players", userId);
        const docSnap = await getDoc(playerDocRef); 
        if (!docSnap.exists() || !docSnap.data().totalGamesPlayed) {
            return null;
        }
        const stats = docSnap.data();
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);
        const todayStr = today.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        const yesterdayStr = yesterday.toLocaleDateString('en-CA', { timeZone: 'America/New_York' });
        let finalPlayStreak = stats.playStreak || 0;
        if (stats.lastPlayDate !== todayStr && stats.lastPlayDate !== yesterdayStr) {
            finalPlayStreak = 0;
        }
        return {
            totalGamesPlayed: stats.totalGamesPlayed,
            totalPoints: stats.totalPoints,
            totalWordsFound: stats.totalWordsFound || 0,
            totalLettersFound: stats.totalLettersFound || 0,
            top5Scores: stats.top5Scores || [],
            top5LongestWords: stats.top5LongestWords || [],
            highScore: stats.highScore || 0,
            bestWord: stats.bestWord || { word: '', score: 0 },
            playStreak: finalPlayStreak
        };
    }
    
 async function fetchAndDisplayLeaderboard(type, listElement, loadingElement) {
    if (!listElement) return;
    if (loadingElement) loadingElement.style.display = 'block';
    listElement.innerHTML = '';
    if (!db) {
        listElement.innerHTML = `<p class="text-red-500 text-center p-4">Leaderboard is offline.</p>`;
        if (loadingElement) loadingElement.style.display = 'none';
        return;
    }

    try {
        let html = '';
        const icons = {
            highScore: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 18.75h-9m9 0a3 3 0 0 1 3 3h-15a3 3 0 0 1 3-3m9 0v-3.375c0-.621-.503-1.125-1.125-1.125h-.871M7.5 18.75v-3.375c0-.621.504-1.125 1.125-1.125h.872m5.007 0H9.497m5.007 0a7.454 7.454 0 0 1-.982-3.172M9.497 14.25a7.454 7.454 0 0 0 .981-3.172M5.25 4.236c-.982.143-1.954.317-2.916.52A6.003 6.003 0 0 0 7.73 9.728M5.25 4.236V4.5c0 2.108.966 3.99 2.48 5.228M5.25 4.236V2.721C7.456 2.41 9.71 2.25 12 2.25c2.291 0 4.545.16 6.75.47v1.516M7.73 9.728a6.726 6.726 0 0 0 2.748 1.35m8.272-6.842V4.5c0 2.108-.966 3.99-2.48 5.228m2.48-5.492a46.32 46.32 0 0 1 2.916.52 6.003 6.003 0 0 1-5.395 4.972m0 0a6.726 6.726 0 0 1-2.749 1.35m0 0a6.772 6.772 0 0 1-3.044 0" /></svg>',
            totalPoints: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 0 0 6 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0 1 18 16.5h-2.25m-7.5 0h7.5m-7.5 0-1 3m8.5-3 1 3m0 0 .5 1.5m-.5-1.5h-9.5m0 0-.5 1.5m.75-9 3-3 2.148 2.148A12.061 12.061 0 0 1 16.5 7.605" /></svg>',
            bestWord: '<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456ZM16.894 20.567 16.5 21.75l-.394-1.183a2.25 2.25 0 0 0-1.423-1.423L13.5 18.75l1.183-.394a2.25 2.25 0 0 0 1.423-1.423l.394-1.183.394 1.183a2.25 2.25 0 0 0 1.423 1.423l1.183.394-1.183.394a2.25 2.25 0 0 0-1.423 1.423Z" /></svg>'
        };

        if (type === 'challenge') {
            const todayStr = new Date().toLocaleDateString('en-CA');
            const leaderboardRef = doc(db, "leaderboards", "dailyChallenge");
            const docSnap = await getDoc(leaderboardRef);

            if (!docSnap.exists() || docSnap.data().date !== todayStr || !docSnap.data().topScores || docSnap.data().topScores.length === 0) {
                html += `<p class="text-slate-500 text-center text-sm p-2">No scores yet for today's challenge. Be the first!</p>`;
            } else {
                html += `<h3 class="text-lg font-bold text-slate-800 my-2 sticky top-0 bg-white py-1 flex items-center gap-2">${icons.highScore} Score / Words Found</h3>`;
                const players = docSnap.data().topScores;
                const scores = players.map((player, i) => {
                    const isCurrentUser = player.userId === userId;
                    return `
                        <li class="flex items-center p-2 rounded-lg ${isCurrentUser ? 'bg-blue-100' : (i % 2 === 0 ? 'bg-slate-50' : '')}">
                            <span class="font-bold text-slate-500 w-8 text-center">${i + 1}.</span>
                            <span class="font-semibold text-slate-800 flex-grow truncate mr-4">${player.name}</span>
                            <div class="text-right">
                                <span class="font-bold text-green-500">${player.score.toLocaleString()} pts</span>
                                <span class="font-medium text-slate-500 text-xs ml-2">(${player.wordsFound}/${player.totalWords})</span>
                            </div>
                        </li>`;
                }).join('');
                html += `<ol class="space-y-1">${scores}</ol>`;
            }
        } else if (type === 'all-time') {
            const leaderboardRef = doc(db, "leaderboards", "allTime");
            const docSnap = await getDoc(leaderboardRef);
            if (!docSnap.exists() || !docSnap.data()) {
                 html = `<p class="text-slate-500 text-center text-sm p-2">All-Time leaderboard is not available.</p>`;
            } else {
                const data = docSnap.data();
                const categories = [
                    { key: 'topByHighScore', title: `${icons.highScore} High Score`, valueKey: 'score' },
                    { key: 'topByTotalPoints', title: `${icons.totalPoints} Total Points`, valueKey: 'totalPoints' },
                    { key: 'topByBestWord', title: `${icons.bestWord} Best Word`, valueKey: 'bestWord', nestedKey: 'score' }
                ];
                for (const cat of categories) {
                    html += `<h3 class="text-lg font-bold text-slate-800 my-2 sticky top-0 bg-white py-1 flex items-center gap-2">${cat.title}</h3>`;
                    const players = data[cat.key] || [];
                    if (players.length === 0) {
                        html += `<p class="text-slate-500 text-center text-sm p-2">No players yet.</p>`;
                    } else {
                        const scores = players.map((player, i) => {
                            const isCurrentUser = player.userID === userId;
                            let value = cat.nestedKey ? (player[cat.valueKey] ? `${player[cat.valueKey].word.toUpperCase()} (${player[cat.valueKey].score})` : 'N/A') : (player[cat.valueKey]?.toLocaleString() || 0);
                            return `<li class="flex items-center p-2 rounded-lg ${isCurrentUser ? 'bg-blue-100' : (i % 2 === 0 ? 'bg-slate-50' : '')}"><span class="font-bold text-slate-500 w-8 text-center">${i + 1}.</span><span class="font-semibold text-slate-800 flex-grow truncate mr-4">${player.name}</span><span class="font-bold text-green-500">${value}</span></li>`;
                        }).join('');
                        html += `<ol class="space-y-1">${scores}</ol>`;
                    }
                }
            }
        } else { // ✅ FIX: This is the corrected logic for the timed 'daily' leaderboard
            const leaderboardRef = doc(db, "leaderboards", "daily");
            const docSnap = await getDoc(leaderboardRef);
            if (!docSnap.exists() || !docSnap.data().topByHighScore) { // Check for the new data structure
                html += `<p class="text-slate-500 text-center text-sm p-2">No scores yet today. Be the first!</p>`;
            } else {
                const data = docSnap.data();
                const categories = [
                    { key: 'topByHighScore', title: `${icons.highScore} High Score`, valueKey: 'dailyHighScore' },
                    { key: 'topByTotalScore', title: `${icons.totalPoints} Total Points`, valueKey: 'dailyTotalScore' },
                    { key: 'topByBestWord', title: `${icons.bestWord} Best Word`, valueKey: 'dailyBestWord', nestedKey: 'score' }
                ];
                for (const cat of categories) {
                    html += `<h3 class="text-lg font-bold text-slate-800 my-2 sticky top-0 bg-white py-1 flex items-center gap-2">${cat.title}</h3>`;
                    const players = data[cat.key] || [];
                    if (players.length === 0) {
                        html += `<p class="text-slate-500 text-center text-sm p-2">No players yet.</p>`;
                    } else {
                        const scores = players.map((player, i) => {
                            const isCurrentUser = player.userID === userId;
                            let value = cat.nestedKey ? (player[cat.valueKey] ? `${player[cat.valueKey].word.toUpperCase()} (${player[cat.valueKey].score})` : 'N/A') : (player[cat.valueKey]?.toLocaleString() || 0);
                            return `<li class="flex items-center p-2 rounded-lg ${isCurrentUser ? 'bg-blue-100' : (i % 2 === 0 ? 'bg-slate-50' : '')}"><span class="font-bold text-slate-500 w-8 text-center">${i + 1}.</span><span class="font-semibold text-slate-800 flex-grow truncate mr-4">${player.name}</span><span class="font-bold text-green-500">${value}</span></li>`;
                        }).join('');
                        html += `<ol class="space-y-1">${scores}</ol>`;
                    }
                }
            }
        }
        listElement.innerHTML = html;
    } catch (e) {
        console.error(`Could not fetch ${type} leaderboard`, e);
        listElement.innerHTML = `<p class="text-red-500 text-center p-4">Could not load leaderboard.</p>`;
    } finally {
        if (loadingElement) loadingElement.style.display = 'none';
    }
}
    
   // ✅ REPLACE your old function with this
function setupEventListeners() {
    const pauseModal = document.getElementById('pause-modal');
    const resumeButton = document.getElementById('resume-game-button');
    const restartButton = document.getElementById('restart-game-button');
    const quitButton = document.getElementById('quit-game-button');
    const closePauseButton = document.getElementById('close-pause-modal-button');

    const resumeGame = () => {
        pauseModal.classList.add('hidden');
        if (currentGamemode !== 'daily' && timer > 0) {
            if (isPracticeMode) {
                timerInterval = setInterval(() => { practiceTimeElapsed++; updatePracticeUI(); }, 1000);
            } else {
                timerInterval = setInterval(() => { timer--; updateTimerUI(); if (timer <= 0) endGame(); }, 1000);
            }
        }
    };

    document.body.addEventListener('click', (e) => {
        if (e.target.closest('#menu-button')) {
            e.stopPropagation();
            clearInterval(timerInterval);
            
            // ✅ FIX: Hides the 'New Game' button if the mode is 'daily', and shows it otherwise.
            restartButton.classList.toggle('hidden', currentGamemode === 'daily');
            
            pauseModal.classList.remove('hidden');
        }
    });

    resumeButton.addEventListener('click', resumeGame);
    closePauseButton.addEventListener('click', resumeGame);
    restartButton.addEventListener('click', () => {
        pauseModal.classList.add('hidden');
        startGame(isPracticeMode, currentGamemode);
    });
    quitButton.addEventListener('click', () => {
        pauseModal.classList.add('hidden');
        resetGame();
    });
    pauseModal.addEventListener('click', (e) => {
        if (e.target === pauseModal) { resumeGame(); }
    });
}
    
    function cacheTilePositions(gridEl) {
    if (!gridEl) return;
    tilePositions = [];
    for (const tile of gridEl.children) {
        const rect = tile.getBoundingClientRect();
        tilePositions.push({
            el: tile,
            center: { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 },
            hitRadius: 0.45 * tile.offsetWidth
        });
    }
}

function resizeCanvas() {
    if (!activeGridEl || !activeCanvasEl) return;
    const gridRect = activeGridEl.getBoundingClientRect();
    activeCanvasEl.width = gridRect.width;
    activeCanvasEl.height = gridRect.height;
    cacheTilePositions(activeGridEl);
    drawLines();
}

function drawLines() {
    if (!activeCtx || !activeCanvasEl) return;
    clearLines();
    if (selectedTiles.length < 2) return;

    activeCtx.beginPath();
    activeCtx.strokeStyle = "rgba(59, 130, 246, 0.8)";
    activeCtx.lineWidth = 12;
    activeCtx.lineCap = "round";
    activeCtx.lineJoin = "round";

    selectedTiles.forEach((tile, index) => {
        const center = getTileCenter(tile);
        if (index === 0) {
            activeCtx.moveTo(center.x, center.y);
        } else {
            activeCtx.lineTo(center.x, center.y);
        }
    });
    activeCtx.stroke();
}

function clearLines() {
    if (activeCtx && activeCanvasEl) {
        activeCtx.clearRect(0, 0, activeCanvasEl.width, activeCanvasEl.height);
    }
}

function getTileCenter(tile) {
    if (!activeGridEl) return { x: 0, y: 0 };
    const gridRect = activeGridEl.getBoundingClientRect();
    const tileRect = tile.getBoundingClientRect();
    return {
        x: tileRect.left + tileRect.width / 2 - gridRect.left,
        y: tileRect.top + tileRect.height / 2 - gridRect.top
    };
}

    function checkNoClumps(board) {
        for (let row = 0; row <= 2; row++) {
            for (let col = 0; col <= 2; col++) {
                const topLeft = row * GRID_COLS + col;
                const topRight = topLeft + 1;
                const bottomLeft = topLeft + GRID_COLS;
                const bottomRight = bottomLeft + 1;

                const clumpLetters = [board[topLeft], board[topRight], board[bottomLeft], board[bottomRight]];
                const areAllVowels = clumpLetters.every(letter => VOWELS.includes(letter));
                const areAllConsonants = clumpLetters.every(letter => !VOWELS.includes(letter));

                if (areAllVowels || areAllConsonants) {
                    return false;
                }
            }
        }
        return true;
    }
    
    function generateAndValidateBoard(existingBoard = null, validatorFn = isBoardPlayable, wordToAvoid = null) {
    const MAX_ATTEMPTS = 200;

    for (let i = 0; i < MAX_ATTEMPTS; i++) {
        let board = existingBoard ? [...existingBoard] : new Array(GRID_SIZE).fill(null);
        
        board.forEach((tile, index) => {
            if (tile === null) {
                board[index] = getRandomLetter();
            }
        });

        if (validatorFn(board)) {
            if (wordToAvoid) {
                const newWords = solveBoard(board, fullDictionaryTrie);
                if (newWords.has(wordToAvoid)) {
                    continue; 
                }
            }
            // ✅ FIX: The console message has been added back.
            console.log(`Generated a valid board in ${i + 1} attempts.`);
            return board;
        }
    }

    console.error(`FAILED to generate a valid board after ${MAX_ATTEMPTS} attempts.`);
    
    let fallbackBoard = existingBoard ? [...existingBoard] : new Array(GRID_SIZE).fill(null);
    fallbackBoard.forEach((tile, index) => {
        if (tile === null) fallbackBoard[index] = getRandomLetter();
    });
    return fallbackBoard;
}
    
   function isBoardPlayable(board) {
    const vowelCount = board.filter(letter => VOWELS.includes(letter)).length;
    if (vowelCount < 4 || vowelCount > 7) return false;

    const hardConsonantCount = board.filter(letter => HARD_CONSONANTS.includes(letter)).length;
    if (hardConsonantCount > 1) return false;

    const qIndex = board.indexOf("Q");
    if (qIndex !== -1 && !getNeighbors(qIndex, board).some(letter => letter === "U")) {
        return false;
    }

    const solvableWords = solveBoard(board, validationTrie);

    // --- ADD THIS LINE (to be removed) ---
    //console.log('Available words on board:', Array.from(solvableWords).sort());

        // This is the new, stricter logic
    const threeLetterWords = Array.from(solvableWords).filter(w => w.length === 3).length;
    const fourLetterWords = Array.from(solvableWords).filter(w => w.length === 4).length;
    const fiveLetterWords = Array.from(solvableWords).filter(w => w.length >= 5).length;

    // Now, require more words, including at least one 5-letter word
    if (threeLetterWords < 4 || fourLetterWords < 3 || fiveLetterWords < 1) {
        return false;
    }

    if (!checkNoClumps(board)) return false;

    return true;
}
    
    function getNeighbors(index, board) {
        const neighbors = [];
        const [col, row] = [index % GRID_COLS, Math.floor(index / GRID_COLS)];

        for (let r_offset = -1; r_offset <= 1; r_offset++) {
            for (let c_offset = -1; c_offset <= 1; c_offset++) {
                if (r_offset === 0 && c_offset === 0) continue;

                const [checkCol, checkRow] = [col + c_offset, row + r_offset];
                if (checkCol >= 0 && checkCol < GRID_COLS && checkRow >= 0 && checkRow < GRID_COLS) {
                    neighbors.push(board[checkRow * GRID_COLS + checkCol]);
                }
            }
        }
        return neighbors;
    }
    
    function solveBoard(board, trie) {
    const foundWordsSet = new Set();
    for (let i = 0; i < GRID_SIZE; i++) {
        findWordsRecursive(i, "", [i], foundWordsSet, board, trie);
    }
    return foundWordsSet;
}

   function findWordsRecursive(tileIndex, currentPrefix, path, foundWordsSet, board, trie) {
    currentPrefix += board[tileIndex];

    if (!trie || !trie.search(currentPrefix, true)) {
        return;
    }

    if (currentPrefix.length >= 3 && trie.search(currentPrefix)) {
        foundWordsSet.add(currentPrefix);
    }

    const [col, row] = [tileIndex % GRID_COLS, Math.floor(tileIndex / GRID_COLS)];
    for (let r_offset = -1; r_offset <= 1; r_offset++) {
        for (let c_offset = -1; c_offset <= 1; c_offset++) {
            if (r_offset === 0 && c_offset === 0) continue;

            const [nextCol, nextRow] = [col + c_offset, row + r_offset];
            const nextIndex = nextRow * GRID_COLS + nextCol;

            if (nextCol >= 0 && nextCol < GRID_COLS && nextRow >= 0 && nextRow < GRID_COLS && !path.includes(nextIndex)) {
                findWordsRecursive(nextIndex, currentPrefix, [...path, nextIndex], foundWordsSet, board, trie);
            }
        }
    }
}

    async function shareScore() {
        const bestWordFound = foundWords.length > 0 ? foundWords.reduce((best, current) => current.score > best.score ? current : best, { word: '', score: 0 }) : null;
        let shareText = `I just scored ${score} on Word Worm! 🐛\n`;
        if (bestWordFound && bestWordFound.word) {
            shareText += `My best word was ${bestWordFound.word.toUpperCase()} for ${bestWordFound.score} points!\n\n`;
        }
        const gameUrl = 'https://wordwormgame.com/';
        shareText += `Think you can beat me? Play now:\n${gameUrl}`;
        const shareData = { title: 'Word Worm', text: shareText };
        if (navigator.share) {
            try { await navigator.share(shareData); console.log('Score shared successfully!'); } catch (err) { console.error('Share failed:', err); }
        } else {
            try {
                await navigator.clipboard.writeText(shareText);
                const shareButton = document.getElementById('share-score-link');
                if (shareButton) {
                    const originalText = shareButton.innerHTML;
                    shareButton.innerHTML = 'Copied! ✓';
                    shareButton.classList.add('text-green-500');
                    setTimeout(() => {
                        shareButton.innerHTML = originalText;
                        shareButton.classList.remove('text-green-500');
                    }, 2000);
                }
            } catch (err) { console.error('Failed to copy: ', err); alert('Could not copy score to clipboard.'); }
        }
    }

   function showEndGameScreen() {
    endGameModal.classList.remove('hidden');
    
    const sortedWords = [...foundWords].sort((a,b)=>b.score-a.score);
    const foundWordsHTML = sortedWords.length ? sortedWords.map(fw => `<div class="flex justify-between text-sm p-1 ${sortedWords.indexOf(fw) % 2 === 0 ? 'bg-slate-50' : ''} rounded"><span class="font-semibold">${fw.word.toUpperCase()}</span><span>+${fw.score}</span></div>`).join('') : '<p class="text-sm text-slate-500 text-center py-4">No words found.</p>';

    endGameModalContent.innerHTML = `<div class="bg-white rounded-2xl shadow-2xl p-6 text-center w-full max-w-sm mx-auto modal-enter">
        <h2 class="text-3xl font-black text-green-500">Great Game!</h2>
        <p class="text-slate-600 mb-2">Your final score is:</p>
        <p id="final-score-display" class="text-6xl font-black text-slate-800 mb-3">${score}</p>
        
        <div id="submission-container" class="h-8 flex items-center justify-center">
            <div class="animate-spin rounded-full h-8 w-8 border-b-2 border-slate-900"></div>
        </div>

        <hr class="my-4">
        <div class="text-left w-full">
            <div class="flex justify-between items-baseline mb-2">
                <h3 class="text-xl font-bold text-slate-700">Your Words (${foundWords.length})</h3>
                <button id="endgame-stats-button" class="flex items-center text-base font-bold text-blue-500 hover:text-blue-600">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5"><path stroke-linecap="round" stroke-linejoin="round" d="M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z" /></svg>
                    <span class="ml-1">Your Stats</span>
                </button>
            </div>
            <div class="space-y-1 max-h-48 overflow-y-auto pr-2">${foundWordsHTML}</div>
        </div>
        <div id="share-link-container" class="h-10 flex items-center justify-center"></div>
        <div class="flex space-x-2 mt-3">
            <button id="endgame-leaderboard-button" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold py-3 px-4 rounded-lg text-base flex-1">Leaderboard</button>
            <button id="play-again-button" class="bg-green-500 hover:bg-green-600 w-full text-white font-bold py-3 px-4 rounded-lg text-base flex-1">Play Again</button>
        </div>
        <div class="text-center text-xs text-slate-400 mt-4">
            <p>&copy; 2025 Word Worm</p>
            <p><a href="/about.html" class="hover:underline">About</a> &bull; <a href="/contact.html" class="hover:underline">Contact</a> &bull; <a href="/privacy.html" class="hover:underline">Privacy Policy</a> &bull; <a href="/terms.html" class="hover:underline">Terms of Use</a></p>
        </div>
    </div>`;
    
    const scoreDisplay = document.getElementById('final-score-display');
    if (scoreDisplay) {
        triggerEndGameConfetti(scoreDisplay);
    }
    
    // This call happens after the modal is shown. processEndOfGame will
    // then replace the spinner with the name input if needed.
    if (!isPracticeMode && db && userId) {
        processEndOfGame(score, foundWords, userId);
    }

    document.getElementById('play-again-button').onclick = resetGame;
    document.getElementById('endgame-leaderboard-button').onclick = showLeaderboardModal;
    document.getElementById('endgame-stats-button').onclick = showStatsModal;
    
    const shareLinkContainer = document.getElementById('share-link-container');
    if (navigator.share || navigator.clipboard) {
        const shareIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 mr-1"><path stroke-linecap="round" stroke-linejoin="round" d="M7.217 10.907a2.25 2.25 0 1 0 0 2.186m0-2.186c.18.324.283.696.283 1.093s-.103.77-.283 1.093m0-2.186 9.566-5.314m-9.566 7.5 9.566 5.314m0 0a2.25 2.25 0 1 0 3.935 2.186 2.25 2.25 0 0 0-3.935-2.186Zm0-12.814a2.25 2.25 0 1 0 3.933-2.185 2.25 2.25 0 0 0-3.933 2.185Z" /></svg>`;        shareLinkContainer.innerHTML = `<a href="#" id="share-score-link" class="flex items-center text-blue-500 hover:underline font-bold">${shareIcon} Share Score</a>`;
        shareLinkContainer.innerHTML = `<a href="#" id="share-score-link" class="flex items-center text-blue-500 hover:underline font-bold">${shareIcon} Share Score</a>`;
        document.getElementById('share-score-link').onclick = (e) => { e.preventDefault(); shareScore(); };
    }
}
    
    function updateEndGameSubmissionUI(playerName, rankInfo) {
    const submissionContainer = document.getElementById('submission-container');
    if (!submissionContainer) return;

    let finalMessageHtml = '';
    const trophyIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M3.75 3v11.25A2.25 2.25 0 0 0 6 16.5h2.25M3.75 3h-1.5m1.5 0h16.5m0 0h1.5m-1.5 0v11.25A2.25 2.25 0 0 1 18 16.5h-2.25m-7.5 0h7.5m-7.5 0-1 3m8.5-3 1 3m0 0 .5 1.5m-.5-1.5h-9.5m0 0-.5 1.5m.75-9 3-3 2.148 2.148A12.061 12.061 0 0 1 16.5 7.605" /></svg>`;
    const checkIcon = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 mr-2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12.75 11.25 15 15 9.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg>`;

    // ✅ FIX: This new logic prioritizes showing your rank first.
    if (rankInfo && rankInfo.rank && rankInfo.rank <= 10) {
        const leaderboardMessage = `You placed&nbsp;<strong>#${rankInfo.rank}</strong>&nbsp;on today's leaderboard!`;
        finalMessageHtml = `<div class="flex items-center justify-center text-green-600 font-bold pop-in whitespace-nowrap">${trophyIcon} ${leaderboardMessage}</div>`;
    } else if (rankInfo && rankInfo.didBeatDailyHighScore) {
        const leaderboardMessage = `New daily high: <strong>${score}</strong>!`;
        finalMessageHtml = `<div class="flex items-center justify-center text-green-600 font-bold pop-in whitespace-nowrap">${trophyIcon} ${leaderboardMessage}</div>`;
    } else {
        const standardMessage = `Score submitted as&nbsp;<strong>${playerName}</strong>!`;
        finalMessageHtml = `<div class="flex items-center justify-center text-green-600 font-bold pop-in whitespace-nowrap">${checkIcon} ${standardMessage}</div>`;
    }
    submissionContainer.innerHTML = finalMessageHtml;
}
    
    
   function setupTutorial() {
    // Get the main container for the tutorial, which is created by showWelcomeScreen()
    const container = document.getElementById('how-to-play-container');
    if (!container) return;

    // --- 1. Define the HTML structure for the new animation ---
    // This is taken directly from the new animation file you provided.
    container.innerHTML = `
        <h3 class="text-md font-bold text-slate-700 text-center mb-2 shrink-0">How to Play</h3>
        <div id="how-to-play-content" class="flex-grow overflow-y-auto pr-2">
            <div class="flex flex-col items-center justify-center space-y-1">
                <div id="tutorial-word-builder" class="h-7 p-1 bg-white rounded-lg shadow-inner w-32 flex items-center justify-center space-x-1"></div>
                <div id="tutorial-grid" class="grid grid-cols-4 gap-1 w-40 h-40 relative"></div>
                <div class="h-6 text-center text-xs font-semibold text-blue-600 flex items-center justify-center gap-1">
                    <svg class="w-4 h-4 scroll-prompt-arrow" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>
                    <span>Scroll down for game rules and tips!</span>
                    <svg class="w-4 h-4 scroll-prompt-arrow" fill="none" viewBox="0 0 24 24" stroke-width="2.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m19.5 8.25-7.5 7.5-7.5-7.5" /></svg>
                </div>
            </div>
            <div class="text-left text-xs space-y-3 mt-3">
                 <ul class="space-y-1">
                    <li class="flex items-start"><span class="inline-block w-5 h-5 mr-2 shrink-0 text-black"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m12.75 15 3-3m0 0-3-3m3 3h-7.5M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Z" /></svg></span><span><strong>How to Play:</strong> Trace letters to form words of 3 or more.</span></li>
                    <li class="flex items-start"><span class="inline-block w-5 h-5 mr-2 shrink-0 text-black"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M16.5 18.75h-9m9 0a3 3 0 0 1 3 3h-15a3 3 0 0 1 3-3m9 0v-3.375c0-.621-.503-1.125-1.125-1.125h-.871M7.5 18.75v-3.375c0-.621.504-1.125 1.125-1.125h.872m5.007 0H9.497m5.007 0a7.454 7.454 0 0 1-.982-3.172M9.497 14.25a7.454 7.454 0 0 0 .981-3.172M5.25 4.236c-.982.143-1.954.317-2.916.52A6.003 6.003 0 0 0 7.73 9.728M5.25 4.236V4.5c0 2.108.966 3.99 2.48 5.228M5.25 4.236V2.721C7.456 2.41 9.71 2.25 12 2.25c2.291 0 4.545.16 6.75.47v1.516M7.73 9.728a6.726 6.726 0 0 0 2.748 1.35m8.272-6.842V4.5c0 2.108-.966 3.99-2.48 5.228m2.48-5.492a46.32 46.32 0 0 1 2.916.52 6.003 6.003 0 0 1-5.395 4.972m0 0a6.726 6.726 0 0 1-2.749 1.35m0 0a6.772 6.772 0 0 1-3.044 0" /></svg></span><span><strong>Your Goal:</strong> Score as many points as you can in 60 seconds.</span></li>
                    <li class="flex items-start"><span class="inline-block w-5 h-5 mr-2 shrink-0 text-black"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M7.5 14.25v2.25m3-4.5v4.5m3-6.75v6.75m3-9v9M6 20.25h12A2.25 2.25 0 0 0 20.25 18V6A2.25 2.25 0 0 0 18 3.75H6A2.25 2.25 0 0 0 3.75 6v12A2.25 2.25 0 0 0 6 20.25Z" /></svg></span><span><strong>How to Score:</strong> Your score is the sum of letter points and any bonuses.</span></li>
                    <li class="flex items-start"><span class="inline-block w-5 h-5 mr-2 shrink-0 text-black"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M11.48 3.499a.562.562 0 0 1 1.04 0l2.125 5.111a.563.563 0 0 0 .475.345l5.518.442c.499.04.701.663.321.988l-4.204 3.602a.563.563 0 0 0-.182.557l1.285 5.385a.562.562 0 0 1-.84.61l-4.725-2.885a.562.562 0 0 0-.586 0L6.982 20.54a.562.562 0 0 1-.84-.61l1.285-5.386a.562.562 0 0 0-.182-.557l-4.204-3.602a.562.562 0 0 1 .321-.988l5.518-.442a.563.563 0 0 0 .475-.345L11.48 3.5Z" /></svg></span><span><strong>Pro-Tip:</strong> Use bonuses and long words to maximize your score!</span></li>
                 </ul>
                 <div><strong class="font-semibold text-slate-700">Bonus Tiles:</strong>
                     <div class="grid grid-cols-2 gap-x-4 mt-1">
                         <ul class="list-none space-y-1">
                             <li class="flex items-center"><span><span class="inline-block text-white text-center font-bold rounded px-1.5 py-0.5 mr-2 w-8" style="background-color: #3b82f6;">DL</span> Double Letter</span></li>
                             <li class="flex items-center"><span><span class="inline-block text-white text-center font-bold rounded px-1.5 py-0.5 mr-2 w-8" style="background-color: #ef4444;">TL</span> Triple Letter</span></li>
                         </ul>
                         <ul class="list-none space-y-1">
                             <li class="flex items-center"><span><span class="inline-block text-white text-center font-bold rounded px-1.5 py-0.5 mr-2 w-8" style="background-color: #f59e0b;">DW</span> Double Word</span></li>
                             <li class="flex items-center"><span><span class="inline-block text-white text-center font-bold rounded px-1.5 py-0.5 mr-2 w-8" style="background-color: #22c55e;">+5s</span> Extra Time</span></li>
                         </ul>
                     </div>
                 </div>
                 <div><strong class="font-semibold text-slate-700">Long Word Bonus:</strong>
                     <table class="w-full mt-1 text-left text-xs">
                         <tbody>
                             <tr><td class="py-0.5 pr-2">4 Letters: <span class="font-medium">+5 pts</span></td><td class="py-0.5">6 Letters: <span class="font-medium">+20 pts</span></td></tr>
                             <tr><td class="py-0.5 pr-2">5 Letters: <span class="font-medium">+10 pts</span></td><td class="py-0.5">7+ Letters: <span class="font-medium">+40 pts</span></td></tr>
                         </tbody>
                     </table>
                 </div>
                  <div><strong class="font-semibold text-slate-700">Letter Point Values:</strong>
                      <div id="letter-values-container" class="flex flex-wrap gap-1 mt-1"></div>
                  </div>

                  <div class="pt-2 mt-2 border-t">
                    <strong class="font-semibold text-slate-700">Daily Challenge Mode:</strong>
                    <p class="mt-1">The Daily Challenge is a static board that resets every day. Find as many words as you can, and the hit 'Submit' when done to be added to the leaderboard!</p>
                </div>

                  <!-- NEW PRACTICE BUTTON ADDED HERE -->
                 <div class="pt-4 mt-4 border-t border-slate-200">
                <p class="text-center text-sm font-semibold text-slate-600 mb-2">Practice without the timer here!</p>
                <div class="flex justify-center">
                    <button id="play-practice-button" class="bg-slate-700 hover:bg-slate-800 text-white font-bold py-2 px-5 rounded-lg text-sm">
                        Practice
                    </button>
                </div>
            </div>
        </div>
    `;

    // --- 2. Get DOM elements and set up constants for the animation ---
    const gridEl = document.getElementById('tutorial-grid');
    const wordBuilderEl = document.getElementById('tutorial-word-builder');
    const letterValuesContainer = document.getElementById('letter-values-container');

    // Display letter point values (this is also from the new code)
    if (letterValuesContainer) {
        const sortedLetters = Object.keys(letterConfig).sort();
        const letterTilesHtml = sortedLetters.map(letter => {
            const config = letterConfig[letter];
            return `<span class="bg-slate-200 text-slate-700 font-bold rounded-sm px-1.5 py-0.5 text-[10px] leading-none">${letter}-${config.p}</span>`;
        }).join('');
        letterValuesContainer.innerHTML = letterTilesHtml;
    }

    const initialLetters = ['W', 'A', 'R', 'D', 'O', 'R', 'D', 'E', 'B', 'N', 'M', 'I', 'S', 'L', 'P', 'T'];
    const bonusTiles = [
        { index: 5, type: 'TL', label: 'TL' },
        { index: 15, type: 'DW', label: 'DW' },
        { index: 12, type: 'Time', label: '+5s' }
    ];

    // --- 3. Define the animation helper functions ---
    // These are also copied from your new animation file.
    function setupGrid(letters) {
        gridEl.innerHTML = '';
        letters.forEach((letter, i) => {
            const tile = document.createElement('div');
            const points = letterConfig[letter]?.p || 1;
            // The class names here match the new CSS you provided.
            tile.className = 'tut-tile';
            tile.id = `tut-tile-${i}`;
            tile.innerHTML = `<span>${letter}<sub>${points}</sub></span>`;
            const bonus = bonusTiles.find(b => b.index === i);
            if (bonus) {
                tile.classList.add(`bonus-${bonus.type.toLowerCase()}-tut`);
                const bonusLabel = document.createElement('div');
                bonusLabel.className = 'bonus-label';
                bonusLabel.textContent = bonus.label;
                tile.appendChild(bonusLabel);
            }
            gridEl.appendChild(tile);
        });
    }

    function createFlyingScore(points, container) {
        const scoreEl = document.createElement('div');
        // The class name here matches the new CSS you provided.
        scoreEl.className = 'flying-score-tut';
        scoreEl.textContent = `+${points}`;
        container.appendChild(scoreEl);
        setTimeout(() => scoreEl.remove(), 1500);
    }

    function drawLine(startTile, endTile) {
        const line = document.createElement('div');
        // The class name here matches the new CSS you provided.
        line.className = 'line-segment';
        const rect1 = startTile.getBoundingClientRect();
        const rect2 = endTile.getBoundingClientRect();
        const gridRect = gridEl.getBoundingClientRect();
        const x1 = rect1.left + rect1.width / 2 - gridRect.left;
        const y1 = rect1.top + rect1.height / 2 - gridRect.top;
        const x2 = rect2.left + rect2.width / 2 - gridRect.left;
        const y2 = rect2.top + rect2.height / 2 - gridRect.top;
        const length = Math.sqrt((x2 - x1)**2 + (y2 - y1)**2);
        const angle = Math.atan2(y2 - y1, x2 - x1) * (180 / Math.PI);
        line.style.width = `${length}px`;
        line.style.left = `${x1}px`;
        line.style.top = `${y1 - 3}px`;
        line.style.transform = `rotate(${angle}deg)`;
        gridEl.appendChild(line);
        setTimeout(() => { line.style.opacity = '1'; }, 10);
    }

    // --- 4. Define and run the main animation sequence ---
    async function runAnimation() {
        // Only run the animation if the modal is actually visible.
        if (messageModal.classList.contains('hidden')) {
            // Stop if the modal closes mid-animation.
            if(animationInterval) clearInterval(animationInterval);
            return;
        }

        const pause = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        wordBuilderEl.innerHTML = '';
        // Clear old lines before starting a new loop
        const oldLines = gridEl.querySelectorAll('.line-segment');
        oldLines.forEach(line => line.remove());
        setupGrid(initialLetters);
        
        const sequence = [
            { index: 0, letter: 'W' }, { index: 4, letter: 'O' },
            { index: 5, letter: 'R' }, { index: 10, letter: 'M' }
        ];

        for (let i = 0; i < sequence.length; i++) {
            // Check again inside the loop in case the modal was closed.
            if (messageModal.classList.contains('hidden')) return;

            const step = sequence[i];
            const tile = document.getElementById(`tut-tile-${step.index}`);
            
            if (i > 0) {
                const prevTile = document.getElementById(`tut-tile-${sequence[i-1].index}`);
                drawLine(prevTile, tile);
                await pause(100);
            }
            
            tile.classList.add('highlight');
            wordBuilderEl.innerHTML += `<span class="bg-white text-blue-500 font-bold text-sm p-0.5 rounded-md shadow-sm">${step.letter}</span>`;
            
            if (i === sequence.length - 1) {
                await pause(200);
                createFlyingScore(13, gridEl);
            }
            
            await pause(700);
        }
    }

    // Clear any previous interval before starting a new one.
    // The `animationInterval` variable should be declared in your main game script's scope.
    if (animationInterval) clearInterval(animationInterval);

    // Initial run and set interval
    runAnimation();
    animationInterval = setInterval(runAnimation, 5000);

    document.getElementById('play-practice-button').onclick = () => startGame(true);
}

    document.addEventListener('DOMContentLoaded', main);
</script>
</body>
</html>